\subsection{Tyrimo objektas}

    Tyrimo objektas yra reaktyvaus programavimo bei įvykių kaupimo principai. Reaktyvus programavimas yra susijęs su reaktyviomis sistemomis, o kalbant apie įvykių kaupimo sistemas, įvykių kaupimo principas yra dažniausiai neatsiejamas nuo komandų-užklausų atsakomybių atskyrimo principo. Dėl to reikia apžvelgti ir pačią sistemą, įkomponuojančią šiuos principus, jog būtų galima susidaryti sistemos architektūros (aukštesnės abstrakcijos) vaizdą bei analizuoti panaudojimo atvejus.

\subsection{Darbo tikslas}

  Darbo tikslas yra pritaikyti reaktyvaus programavimo principus įvykių kaupimo sistemose taip, jog būtų išpildyti šie reikalavimai:

  \begin{itemize}

    \item reaktyviojo programavimo programos sąsaja (API) būtų valdoma atgalinių iškvietimų.

    \item reaktyviojo programavimo programos sąsaja (API) būtų deklaratyvi, tai yra leistų naudoti reaktyvius operatorius.

    \item įvykių kaupimo sistemos skaitymo modelis būtų kuriamas naudojant reaktyviojo programavimo programos sąsają (API).

    \item įvykių kaupimo sistemos skaitymo modelį būtų galima kurti asinchroniškai.

    \item naudojant reaktyviojo programavimo programos sąsają (API) būtų galima kurti Reaktyvumo manifeste aprašytas reaktyvias sistemas, tai yra būtini bruožai būtų išpildomi (atkuriamumas, reagavimas į įvykius, našumas).

\end{itemize}

\subsection{Darbo uždaviniai}

  Siekiant tikslo, turi būti išspręsti šie uždaviniai:

\begin{itemize}
        \item sukurti konceptualų architektūros modelį, apjungiantį reaktyvų programavimą bei įvykių kaupimo principus.
        \item išnagrinėti egzistuojančią (-ias) reaktyvaus programavimo bibliotekas.
        \item išnagrinėti egzistuojančią (-ias) įvykių kaupimo bibliotekas ar programavimo karkasus.
        \item sukurti arba praplėsti esamą konkretizuotą kalbą (angl. domain specific language), apjungiančią reaktyvaus programavimo bei įvykių kaupimo principus;
        \item aprašyti konkretizuotuos kalbos kūrimo metodiką, apibrėžti gautų rezultatų apribojimus, suformuluoti iškilusias problemas bei paaiškinti jų priežastis.
\end{itemize}

\subsection{Darbo nauda įgyvendinus tikslą}

Kadangi reaktyvus programavimas leidžia kurti sistemas komponavimo būdu, deklaratyviai, pasiekus tikslą būtų galima supaprastinti įvykių kaupimu pagrįstų sistemų kūrimą, struktūrizuoti kodą į smulkesnius, lengviau suprantamus ir palaikomus komponentus. Toks atskyrimas leistų atlikti panašią paskirtį kaip modelio-kontrolieriaus-vaizdo projektavimo šablono maršrutizatorius. Būtų galima apsirašyti kas ir kokius įvykius apdoroja su papildoma galimybe filtruoti ir transformuoti gautus įvykius prieš perduodant valdymą įvykio apdorotojui.

\subsection{Tyrimo aktualumas}

Reaktyvusis programavimas (RP) yra nauja programavimo kalbos paradigma, konkrečiai taikoma reaktyviosioms programoms kurti. Per pastaruosius keletą metų vis daugiau įmonių ir programų kūrėjų pradėjo naudoti RP žiniatinklio programoms, vartotojo sąsajoms ir asinchroninei įvykių valdomai programinei įrangai kurti. RP tapo ypač populiarus „JavaScript“ bendruomenėje, kur tokios bibliotekos kaip „Angular.js“ ir „Bacon.js“ priėmė reaktyviąją paradigmą, palaikančią automatinį keitimų platinimą.

Įrodyta, kad RP leidžia programų kūrėjui realizuoti reaktyviąsias programas komponavimo būdu, paverčiant abstrakcija tokias detales kaip duomenų priklausomybės aptikimas, dėl ko reaktyviąją programinę įrangą tampa lengviau suprasti.

Reaktyvusis programavimas – tai nauja programavimo paradigma, pritaikyta reaktyviosioms programoms kurti. Reaktyviojo programavimo kalbų yra įvairių, tačiau jų pagrindinė mintis, kad programų kūrėjai deklaratyviai pateikia duomenų srauto aprašą programoje. Kalbos vykdyklė apdoroja platinamus keitimus ir priklausomų reikšmių perskaičiavimą, kai to reikia.

Nors tai dar naujas metodas, reaktyvusis programavimas yra jau plačiai naudojamas programavimo modelis. Reaktyvųjį programavimą naudoja ir „Microsoft“ bei „Netflix“. Iš kūrimo perspektyvos, reaktyviojo programavimo tikslas yra sumažinti reaktyviųjų programų sudėtingumą. Be to, reaktyvusis programavimas padaro jas geriau prižiūrimas ir sumažina klaidų skaičių.

Įvykių kaupimo principo esmė – objektas yra atvaizduojamas kaip įvykių seka. Kaip pavyzdį tai galima parodyti remiantis banko sąskaita. Tarkime vartotojas, banko klientas, turi 100 eurų sąskaitos balansą. Tarkime vartotojas nusipirko prekę už 20 eurų, tada įnešė į savo sąskaitą 15 eurų ir galiausiai nusipirko tam tikrą paslaugą už 30 eurų. Akivaizdu, jog turint šią įvykių seką, galima atvaizduoti dabartinę objekto būseną - tai yra 65 eurai vartotojo sąskaitoje. Įvykių kaupimo principas užtikrina, jog visi būsenos pasikeitimai yra saugomi įvykių žurnale kaip įvykių seka \cite{vernon2013implementing}. Įvykių kaupimo principui yra būdinga, jog įvykių negalima ištrinti bei atnaujinti, duomenys yra nekeičiami, dėl to įvykių žurnalas yra sistemos gyvavimo istorija (tiesos šaltinis). Tačiau toks modelis turi ir trūkumų. Jis nėra pritaikytas patogiam užklausų rašymui. Iš įvykių srautų yra kuriamos projekcijos, skirtos konkretiems sistemoms poreikiams, pavyzdžiui: paieškai, klasifikacijai ar ataskaitų ruošimui.

Pritaikius reaktyvų programavimą įvykių kaupimo principu paremtose sistemose būtų galima modeliuoti ne tik momentinius įvykius, tačiau turėti ir jų istoriją. Yra poreikis sukurti konkretizuotą kalbą (angl. domain specific language), kuri įgalintų paslėpti įvykių žurnalą (arba duomenų saugyklą). Pastarosios naudotojas galėtų orientuotis į pačią sprendžiamos srities problemą, nekreipdamas dėmesio į žemesnio lygio realizacijos detales. Šiuo atveju būtų galima deklaratyviai (ką kažkuri programos dalis turi daryti) apsirašyti elgseną, nutikus įvykiui, kartu su imperatyviomis (instrukcijos, kurios aprašo, kaip programos dalys atlieka savo užduotis) struktūromis.

\subsection{Pritaikymo pavyzdys}

Tarkime turime domeno sritį - elektroninė komercija. Norint turėti greitą paieškos algoritmą dažnai naudojama kokia nors NoSQL duomenų bazė, pavyzdžiui ElasticSearch. Įprastas būdas perduoti produktų pakeitimus į šią duomenų bazę yra naudojant atgalinius iškvietimus:

\begin{lstlisting}[]
class Product < ActiveRecord::Base
  after_commit :reindex_product
  after_commit :reindex_user
  # ...
end
\end{lstlisting}

Kiekvieną kartą kai \lstinline|Product| yra sukuriamas, atnaujinamas arba ištrinamas, modelio informacija yra perduodama į kita duomenų saugyklą, skirtą paieškai. Dabar įsivaizduokime programuotojas prideda stulpelį \lstinline|pageviews| šiai lentelei. Jeigu programuotojas nenaudos specialių metodų atnaujinant produkto peržiūrų, skirtų išsaugoti įrašą, bet praleidžiant atgalinius iškvietimus, atsiras be galo daug atnaujinimų paieškos duomenų saugyklai, ko pasekoje visa sistema gali neatlaikyti apkrovos. Tokių atvejų praktikoje pasitaiko neretai. Dažna to priežastis yra sudėtingas sistemos suvokimas, kadangi atgaliniai iškvietimai yra išsisklaidę visoje sistemoje ir sunku pasakyti kas po ko seka. Kartais praktikoje reikia praleisti nemažai laiko derinant ir aiškinantis sistemos veikimą.

Naudojant įvykių kaupimo sistemą ir panaudojant reaktyvų programavimą, atgalinius iškvietimus būtų galima projektuoti daug konkrečiau ir vienoje vietoje. Tai galėtų atrodyti:

\begin{lstlisting}[]
event_store.subscribe([ProductImageUploaded, ProductInformationChanged])
           .each { |event| ReindexProduct.execute(event.id) }
\end{lstlisting}

Čia \lstinline|event_store| yra duomenų srautas, mes nežinome kada bus gauta reikšmė, tačiau jau galime aprašyti logiką, kuri bus pritaikyta ateityje, įvykus tam tikram įvykiui. Tokiu būdu pati domeno srities logika būtų vienoje vietoje ir būtų daug lengviau suprantama. Šių apibrėžimų paskirtis būtų panaši kaip ir maršrutizatoriaus MVC projektavimo šablone. Jie nurodytų kas nutikus vienokiam ar kitokiam įvykiui, turėtų šį įvykį apdoroti. Lygiai taip pat MVC projektavimo šablone maršrutizatorius nurodo koks kontrolierius apdorojo tam tikrą vartotojo užklausą.

Sujungus reaktyvaus programavimo principus bei įvykių kaupimą būtų galima deklaratyviai apsirašyti tokias konstrukcijas kaip \lstinline|filter| bei \lstinline|map|. Konstrukcija \lstinline|filter| veiktų kaip filtravimo operatorius, ir leistų apdoroti tik tuos įvykius kurie atitinka tam tikrą sąlygą. Konstrukcija \lstinline|map| leistų transformuoti įvykius bei galėtų būti naudinga eksperimentavimo tikslais. Turint visą sistemos verslo logikos įvykių istoriją galima būtų iš naujo pritaikyti visus įvykius ir stebėti sistemos elgseną kaitaliojant įvairius parametrus. Pavyzdžiui elektroninės komercijos sistemoje gali būti poreikis įsivesti tam tikrą pirkėjų lojalumo sistemą. Iš pradžių neaišku kiek kam kreditų skirti, kokį procentą nuo produkto sumos. Neaišku kurie vartotojai kiek kreditų sukaups ateityje. Tačiau turint istoriją galima šį atvejį paprastai sumodeliuoti lokaliai. Pažvelkime į pseudokodą:

\begin{lstlisting}[]
module Transformers
  class StoreCreditsMapper
    CREDITS_PERCENTAGE_FOR_PURCHASE = 0.3

    def self.execute(event)
      event.user.store_credits = event.product.price * CREDITS_PERCENTAGE_FOR_PURCHASE
    end
  end
end

event_store.subscribe([ProductPurchase])
           .filter { |event| Filters::EligibleForBuyerLoyaltyProgram.execute(event) }
           .map { |event| Transformers::StoreCreditsMapper.execute(event) }
           .each { |event| ReadModels::User.call(event) }
\end{lstlisting}

Pritaikant visus įvykius iš naujo ir koreguojant tik \lstinline|CREDITS_PERCENTAGE_FOR_PURCHASE| yra gana lengva numatyti pirkėjų sukauptus kreditus per tam tikrą laiką. Toks įvykių maršrutizatoriaus kodas yra deklaratyvus, imperatyvios konstrukcijos yra pritaikomos tik tose vietose kur reikia. Toks būdas labai aiškiai padalintų atsakomybes į filtravimą, duomenų transformavimą ir skaitymo modelio būsenos atnaujinimo operacijas. To pasekoje nebereiktų visų šių veiksmų atlikti ir realizuoti skaitymo modelyje, kaip tai dažniausiai daroma. Skaitymo modelio kodas būtų trumpesnis ir rūpintųsi tik duomenų atnaujinimu. Be to tipiniu atveju nereiktų skaityti visų įrašytų įvykių nurodant likusių kreditų kiekį vartotojui. Užtektų iškviesti \lstinline|current_user.store_credits|.

\subsection{Tyrimo metodika}

    Darbo tikslui pasiekti tiriamojoje dalyje bus pasirinkta Ruby programavimo kalba bei aprašoma kūrimo metodika. Ruby leidžia programuoti tiek objektiškai, tiek funkciškai (palaiko aukštesnės eilės funkcijas).

\subsection{Laukiami rezultatai}

    Magistrinio darbo metu planuojama išnagrinėti reaktyvaus programavimo ir įvykio kaupimo principus. Kadangi šie principai glaudžiai susiję su reaktyviomis sistemomis, komandų-užklausų atskyrimo principu ir domenu pagrįstu projektavimu, reikia apžvelgti ir bendrą sistemos architektūros vaizdą, apjungiančios šiuos principus. Taip pat planuojama praplėsti esamą įvykių kaupimo sistemos biblioteką, realizuojant reaktyvaus programavimo idėjas ir deklaratyvumą, bei aprašyti kūrimo eigos metodiką, apibrėžti gautus rezultatus, suformuluoti apribojimus, iškilusias problemas bei paaiškinti jų priežastis. Taip pat pateikti galimas temas tolesniam darbo analizavimui ir praplėtimui.
