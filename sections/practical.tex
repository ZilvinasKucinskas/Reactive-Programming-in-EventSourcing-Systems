  Šioje dalyje bus bandoma parodyti, jog reaktyvų programavimą galima panaudoti įvykių kaupimo sistemose. Kad būtų galima susidaryti bendrą vaizdą ir suvokti panaudojimo atvejį, pirmiausia reikia suprojektuoti aukštesnį sistemos vaizdą, tai yra suprojektuoti kuriamos sistemos architektūrą. CQRS ir įvykių kaupimo principas dažniausiai naudojami kartu, pritaikant šiuos principus apibrėžtose, sudėtingose, bei verslo logiką apimančiose sistemos srityse. Šiuo atveju pritaikomos ir turimos DDD žinios. Toliau nagrinėjami jau esantys reaktyvaus programavimo įvykių kaupimo programavimo karkasai/bibliotekos. Sekančiame skyriuje seka jų suderinamumo analizė. Aprašomi kilę iššūkiai ir galimi tolimesni darbai.

\subsection{Programavimo kalba ir programavimo karkasas}

Pasirinkta dinaminė ``Ruby'' kalba, palaikanti tiek objektinį tiek funkcinį programavimą. ``Ruby on Rails''\footnote{http://rubyonrails.org/} yra atviro kodo serverio pusės saityno programų programavimo karkasas, parašytas ``Ruby'' kalba. ``Ruby on Rails'' yra paremtas modelio-vaizdo-kontrolieriaus (MVC) projektavimo šablonu, kurį dar 9 dešimtmetyje aprašė Glenn Krasner ir Stephen Pope kaip bendrinę sąvoką \cite{Krasner:1988:CUM:50757.50759}. Verta pabrėžti, jog šis projektavimo šablonas jau buvo naudojamas ir anksčiau Smalltalk programavimo kalboje. Darbo autorius, siekiant išmokti ar sužinoti daugiau apie šį programavimo karkasą, ypatingai rekomenduoja Michael Hartl knygą ``Ruby on Rails Tutorial (Rails 5) Learn Web Development with Rails''\footnote{https://www.railstutorial.org/book}, kuri yra nemokama.

Darbo autorius turi keletą metų profesionalaus darbo su šiomis technologijomis patirties, todėl praktinėje dalyje bus analizuojamos bibliotekos ar programavimo karkasai ir pateikti kodo pavyzdžiai, parašyti ``Ruby'' kalba.

\subsection{Įvykių kaupimo sistemos architektūra}

\ref{img:mvc_cqrs} paveikslėlyje pavaizduotas architektūros modelis naudojant MVC projektavimo šabloną bei apjungiantis komandų-užklausų atskyrimo , įvykių kaupimo principus bei reaktyvųjį programavimą. Toliau ši diagrama bus išsamiau paaiškinta bei aprašyta pagrindiniai proceso tekmės atvejai, komandų operacijos (keičiančios būseną) bei užklausų operacijos (neikeičiančios būsenos).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{img/mvc_cqrs}
    \caption{MVC paremtas architektūros modelis, apjungiantis CQRS, ES bei reaktyvaus programavimo principus}
    \label{img:mvc_cqrs}
\end{figure}

\subsubsection{Pavyzdinis procesas - vartotojas įsideda daiktą į pirkinių krepšelį}

\begin{enumerate}
  \item Vartotojas pateikia užklausą programai įdėti pirkinį į pirkinių krepšelį. Pavyzdinė užklausos semantika - \lstinline|https://mysite.com/cart/add/1|.

  \item Saityno serveris gauna užklausą. Maršrutizatorius naudoja maršrutų failą \lstinline|config/routes.rb| ir identifikuoja kur reikia nusiųsti užklausą. Mūsų atveju \lstinline|cart| yra kontrolierius, \lstinline|add| yra norimas atlikti veiksmas, o \lstinline|1| yra parametras, nurodantis konkretų/unikalų pirkinį.

  \item Kontrolierius iškviečia komandą.

  \item Komanda gali patikrinti ar užklausa buvo validi. Jei užklausa buvo validi, kontrolierius įrašo sėkmingą arba nesėkmingą įvykį į įvykių kaupimo žurnalą. Taipogi komanda gali atlikti tam tikrus šalutinius efekus, tokius kaip elektronių žinučių siuntimas vartotojui.

  \item Kai įvykis įrašomas į įvykių kaupimo žurnalą, reaktyvaus programavimo programos sąsaja (API) reaguoja į įvykį pagal aprašytas taisykles. Taisyklės aprašo ką su tuo įvykiu reikia padaryti, bendru atveju tai dažniausiai yra dabartinės būsenos atnaujinimas tam tikroje kitoje duomenų saugykloje.

  \item Kai tik įvykis jau įrašytas į įvykių žurnalą, galima vartotojui pranešti apie sėkmingą rezultatą.
\end{enumerate}

\subsubsection{Pavyzdinis procesas - vartotojas peržiūri savo pirkinių krepšelį}

\begin{enumerate}
  \item Vartotojas pateikia užklausą programai peržiūrėti savo pirkinių krepšelį. Pavyzdinė užklausos semantika - \lstinline|https://mysite.com/cart|.

  \item Saityno serveris gauna užklausą. Maršrutizatorius naudojo maršrutų failą \lstinline|config/routes.rb| ir identifikuoka kuris kontrolierius atsakys į užklausą.

  \item Kontrolierius iškviečia skaitymo modelį, kuris naudojant Ruby on Rails karkasą įprastai būna supaprastintas (naudojant aktyvų įrašą nereikia rašyti SQL, jis yra sugenerupjamas). Pavyzdinė užklausa \lstinline|@cart = current_user.cart.all|.

  \item Dabartinis vartotojo pirkinių krepšelis yra nuskaitomas iš duomenų saugyklos. Čia reikia prisiminti galutinės darnos sąvybę. Esant didelei apkrovai, egzistuoja galimybė, jog bus nuskaitoma krepšelio būsena kai pirkinys dar nepridėtas į krepšelį. Todėl toks sistemos projektavimas verčia labiau mąstyti apie pačią sistemą. Įprastiniu atveju, pirkinių krepšelis įvykdžius daikto pridėjimo scenarijų, aprašytą aukščiau, galėtų būti pridedamas vartotojo sąsajoje. Vartotojas matytų, jog pirkinys pridėtas į krepšelį, tačiau įvykių kaupimo programavimo programos sąsaja (API) dar galbūt nebūtų baigusi darbo. Įprastiniu atveju, kai vartotojas norėtų pirkti visus krepšelio pirkinius, reaktyviojo programavimo programos sąsaja (API) jau būtų baigusi darbą. Įprastiniu atveju tai trunka keliasdešimt milisekundžių.

  \item Galiausiai vartotojui pateikiamas krepšelio vaizdas.
\end{enumerate}

\subsection{Reaktyvus programavimas Ruby kalboje}

Žemesniame lygyje paradigma iš esmės yra dviejų kūrimo šablonų konstrukcija, naudojama jau daugiau nei 20 metų. Faktiškai viena iš populiariausių kūrimo šablonų knygų yra „Gang of Four“, kurioje aprašyti šie du kūrimo šablonai: iteratoriaus ir stebėtojo šablonai \cite{GOF:DesignPattern}. Tai yra du elgsenos kūrimo šablonai, charakterizuojantys objektų ir klasių sąveiką ir atsakomybę.

\subsubsection{Iteratorius}

Pagrindinė šio šablono (iteratoriaus) idėja – atsakomybė už sąrašo objekto prieigą ir perėjimą ir jo įdėjimas į iteratoriaus objektą. Iteratoriaus klasė apibrėžia prieigos prie sąrašo elementų sąsają. Iteratoriaus objektas atsakingas už esamo elemento stebėjimą; t. y. jis žino, kurie elementai jau buvo pereiti.

„Ruby“ Enumerable modulis kaip tik tai ir daro: pateikia surašytuvą, kuriame yra uždari duomenys ir perėjimo metodai. Parašykime trumpiau: „Ruby“ iteratorius – tai klasės, į kurią įtrauktas \lstinline|Enumerable| modulis, egzempliorius. Kuris yra beveik bet koks rinkinys.

\subsubsection{Stebėtojas}

Stebėtojo šablonas yra kūrimo šablonas, kuriame objektas (vadinamas tema) tvarko jo priklausinių (vadinamų stebėtojais) sąrašą ir automatiškai praneša apie bet kokius būsenos pasikeitimus, paprastai iškviesdamas vieną iš jų metodų. Paprastai jis naudojamas paskirstytųjų įvykių tvarkymo sistemoms realizuoti.

Iš esmės temos yra objektai, kurie siunčia pranešimus į objektus, stebinčius tokias temas. Temos priverstinai įkelia pranešimus stebėtojams, todėl tai ir vadinama stebėtojo šablonu.

„Ruby“ pateikiama su \lstinline|Observable| moduliu standartinėje bibliotekoje, kurioje pateikiamas paprastas mechanizmas, skirtas vienam objektui (temai) informuoti prenumeratorių rinkinį (stebėtojus) apie bet kokį būsenos pasikeitimą.

\subsubsection{Reaktyvus programavimas}

Dabar, kai turime supratimą ir apie iteratoriaus, ir apie stebėtojo šablonus, atėjo laikas suformuoti reaktyviojo programavimo paradigmą

Pagal Reaktyvumo manifestą reaktyviosios sistemos yra: reaguojančios, atkuriamos, lanksčios ir valdomos pranešimais. Tokio tipo apibrėžimai labai glumina. Tai, kaip aš suprantu Reaktyvumo manifestą, reaktyviosios sistemos yra asinchroninės, toleruojančios triktis, išplečiamos ir palaikančios ryšį su neblokuojamu pranešimų perdavimu.

Tačiau mus domina realizavimas, ypač naudojant „Ruby“. Ar nustebtumėte, jei pasakyčiau, kad iš pirmo žvilgsnio reaktyviojo programavimo paradigma iš esmės yra abstrakcija ant stebėtojo ir iteratoriaus šablonų derinio? Toliau bus nagrinėjamos reaktyviojo programavimo bibliotekos ``Ruby'' kalboje.

\subsubsection{Reaktyviojo programavimo bibliotekos}

Darbo autoriui pavyko rasti 2 reaktyviojo programavimo bibliotekas ruby kalboje. Todėl jas plačiau aptarsime.

\begin{itemize}
  \item ``RxRuby''\footnote{https://github.com/ReactiveX/RxRuby} - 595 žvaigždučių bei 52 išsišakojimai, paskutinis atnaujinimas įvyko 2017 metų sausį. (Žiūrėta 2017-01-08)

  \item ``Frappuccino''\footnote{https://github.com/steveklabnik/frappuccino} - 370 žvaigždučių bei 32 išsišakojimai, paskutinis atnaujinimas įvyko 2016 metų vasarį. (Žiūrėta 2017-01-08)
\end{itemize}

``RxRuby'' biblioteka turi labiau apribojančią ``Apache'' licenziją (2 versija) lyginant ``Frappuccino'' MIT licenziją. Bibliotekų peržiūros Github platformoje pateiktos priedų \ref{img:rxruby}, \ref{img:frappuccino} paveikslėliuose.

\subsubsection{RxRuby}

Pirmiausia pažiūrėkime kaip veikia ``RxRuby'' paprasčiausioje formoje:

\begin{lstlisting}[]
  RxRuby::Observable.just(7)
\end{lstlisting}

\lstinline|RxRuby::Observable| yra srautas. Srautas yra tema (arba objektas), kurį galima prenumeruoti (arba stebėti). \lstinline|RxRuby::Observable| modulis pats nedaro nieko, nebent kuris nors jo metodas bus iškviestas. Tęskime pavyzdį:

\begin{lstlisting}[]
  stream = RxRuby::Observable.just(7)
  stream.subscribe {|num| puts "Gautas skaicius #{num}" }
\end{lstlisting}

Objektas, kurį gauname yra tiesiog skaičius 7, apgaubtas kaip tema. Kadangi tema realizuoja daugumą \lstinline|Enumerable| modulio metodų, galima su juo daryti praktiškai bet ką. Tačiau kad išvengtume sudėtingumo šiame pavyzdyje, tiesiog prenumeruokime temą ir perduokime \lstinline|lambda| konstrukciją. \lstinline|Lambda| bus iškviesta kiekvieną kartą kai srautas gaus informaciją (šiuo atveju tik kartą).

Šio pavyzdinio atvejo išvestis bus:

\begin{lstlisting}[]
  Gautas skaicius 7
\end{lstlisting}

Kadangi turime daug \lstinline|Enumerable| modulio metodų, kuriuos galime naudoti, galime kažką nuveikti su masyvu. Yra 2 būdai dirbti su masyvais ``RxRuby'' bibliotekoje: naudojant rėžį ir paprastus masyvus.

\begin{lstlisting}[]
  RxRuby::Observable.range(1,10)
    .select {|num| num.even? }
    .sum
    .subscribe {|s| puts "Suma lyginiu skaiciu tarp 1 ir 10 yra: #{s}" }
\end{lstlisting}

Gražins:

\begin{lstlisting}[]
  Suma lyginiu skaiciu tarp 1 ir 10 yra: 30
\end{lstlisting}

Paanalizuokime šį pavyzdį. Pirmiausia sukuriame temos rėžis, su skaičiais tarp 1 ir 10. Tada iškviečiamas filtravimo operatorius \lstinline|select| temai, perduodant \lstinline|lambda| kaip parametrą. \lstinline|lambda| priima kiekvieną rėžio skaičių kaip parametrą ir filtruoja visus lyginius temos skaičius, grąžindama naują temą. Iškvietus \lstinline|sum| operatorių, susumuojami visi lyginiai skaičiai.

Galiausiai operatoriaus \lstinline|sum| grąžinama tema yra prenumeruojama. Prenumeruojant tema (arba duomenų srautas) tiesiog stebima ir \lstinline|lambda| iškviečiama. Kiekvieną kartą kai tema gauna naują informaciją, duomenys bus perduodami lyg per ``piltuvėlį'' ir paskutinė \lstinline|lambda| atspausdints rezultatą.

\subsubsection{Frapuccino}

Steve Klabnik, žymus žmogus Ruby bendruomenėje dėl savo įnašo į atviro kodo projektus\footnote{https://github.com/steveklabnik}, 2013 metais pristatė reaktyvaus programavimo idėjas Ruby kalboje įvairiose konferencijose, tarp jų Euruko2013 \cite{klabnik:euruko}, RubyConf India 2013 \cite{klabnik:india} ir kitos.

Panagrinėkime šios bibliotekos pavyzdį:

\begin{lstlisting}[]
class Button
  def push
    emit(:pushed) # emit sends a value into the stream
  end
end

button = Button.new
stream = Frappuccino::Stream.new(button)

counter = stream
            .map {|event| event == :pushed ? 1 : 0 } # convert events to ints
            .inject(0) {|sum, n| sum + n } # add them up

counter.now # => 0

button.push
button.push
button.push

counter.now # => 3

button.push

counter.now # => 4
\end{lstlisting}

Ši biblioteka kaip ir RxRuby naudoja stebėtojo projektavimo šabloną. Sukuriant srautą, klasė \lstinline|Button| iš tikrųjų yra dinamiškai išplečia \lstinline|Frappuccino::Source| klasę, kuri ir turi \lstline|emit| metodą. Taipogi \lstinline|Button| klasė paverčiama tema. \lstline|emit| metodas iškviečia \lstinline|notify_observers(value)| metodą ir nauja reikšmė perduodama visiems stebėtojams.

Reaktyvus operatoriai (tokie kaip \lstinline|map|, \lstinline|merge| ir kiti) yra realizuoti grąžinant naują \lstinline|Frappuccino::Stream| obejektą, kuris taipogi yra stebėtojas.

Šiame pavyzdyje yra sukuriamas mygtukas. Kiekvieną kartą kai jis paspaudžiamas vistiem temos stebėtojams yra perduodamas pranešimas apie naują reikšmę. \lstinline|counter| kintamasis parodo kiek kartų buvo paspaustas mygtukas. Nereikia kaskart iš naujo pritaikyti skaičiavimų, biblioteka įgalina apsirašyti elgseną vieną kartą deklaratyviai. \lstinline|map| reaktyvus operatorius transformuoja įvykio reikšmę - jeigu gautas simbolis \lstinline|:pushed| - reikšmė tampa 1, o priešingu atveju 0. Kitas operatorius \lstinline|inject| priima parametrą - pradinę reikšmę (šiuo atveju 0). Kiekvieną kartą kai yra gaunama reikšmė, perduodamas kodo blokas (lambda) yra iškviečiama ir rezultatas atnaujinamas.

Rezultatas yra saugomas atmintyje, todėl programai baigus darbą, reikšmės yra prarandamos. Kaip Steve Klabnik pasakojo savo prezentacijose, tokią biblioteką būtų galima naudoti vartotojo sąsajos programose. Jis teigia, jog pati idėja yra pasiskolinta iš funkcinių programavimo kalbų, ir įdomu pritaikyti naujus principus Ruby programavimo kalboje.

Kadangi reaktyvūs operatoriai grąžina naują stebėtoją - galima programuoti labai deklaratyviai:

\begin{lstlisting}
  merged_stream = Frappuccino::Stream.merge(one_stream , other_stream)
  filtered_stream = merged_stream.select{|event| event == :pushed }

  filtered_stream.on_value do |event|
  # event will only ever be :pushed
  end
\end{lstlisting}

Biblioteka leidžia tiek apjungti, tiek filtruoti, tiek perduoti bloką kodo, kuris bus įvykdomas, kai tik srautas gaus naują informaciją.

\subsection{Įvykių kaupimas Ruby kalboje}

Įvykių kaupimą principą taikančių bibliotekų Ruby kalboje nėra daug. Galima būtų išskirti 3 žinomiausius:

\begin{itemize}
  \item ``RailsEventStore''\footnote{https://github.com/arkency/rails\_event\_store} - 212 žvaigždučių bei 18 išsišakojimų, paskutinis atnaujinimas įvyko 2016 metų gruodį. (Žiūrėta 2017-01-07)

  \item ``Sandthorn''\footnote{https://github.com/Sandthorn/sandthorn} - 110 žvaigždučių bei 4 išsišakojimai, paskutinis atnaujinimas įvyko 2016 metų balandį. (Žiūrėta 2017-01-07)

  \item ``Event Sourced Record''\footnote{https://github.com/fhwang/event\_sourced\_record} - 31 žvaigždutė bei 5 išsišakojimai, paskutinis atnaujinimas įvyko 2015 metų balandį. (Žiūrėta 2017-01-07)
\end{itemize}

Visos bibliotekos turi MIT licenziją. Verta paminėti, jog ``RailsEventStore'' anksčiau turėjo labiau apribojančią LGPLv3\footnote{https://github.com/arkency/rails\_event\_store/commit/212b202f227a98f131dc3e8711e431e1f126b475} licenziją (iki 2016 metų birželio). Bibliotekų peržiūros Github platformoje pateiktos priedų \ref{img:rails_event_store}, \ref{img:sandthorn}, \ref{img:event_sourced_record} paveikslėliuose.

Kadangi ``RailsEventStore'' yra aktyviai atnaujinima, populiariausia iš trijų, atviro kodo, įvykių kaupimą įgyvendinanti biblioteką, ją ir nagrinėsime.

\subsubsection{RailsEventStore}

Įvykių kaupimo biblioteka ``RailsEventStore'' naudoja atskirą biblioteką darbui su įvykiais pavadinimu ``rails\_event\_store\_active\_record''\footnote{https://github.com/arkency/rails\_event\_store\_active\_record}. Pagal nutylėjimą ji yra numatytoji, tačiau esant reikalui lengvai pakeičiama (pavyzdžiui norint naudoti Greg Young ``GetEventStore''\footnote{https://geteventstore.com/} duomenų saugyklą). Taipogi yra galimybė naudoti duomenų saugyklą atmintyje.

\subsubsection{Naudojimas}

Jeigu į ``Ruby on Rails'' projekto \lstinline|Gemfile| failą jau įtrauktas \lstinline|rails_event_store| modulis, reikia sugeneruoti aktyvaus įrašo migraciją:

\begin{lstlisting}[]
  rails generate rails_event_store:migrate
  rake db:migrate
\end{lstlisting}

Ši migracija iš tikrųjų tokią lentelę:

\begin{lstlisting}
    create_table(:event_store_events) do |t|
      t.string      :stream,      null: false
      t.string      :event_type,  null: false
      t.string      :event_id,    null: false
      t.text        :metadata
      t.text        :data,        null: false
      t.datetime    :created_at,  null: false
    end
    add_index :event_store_events, :stream
    add_index :event_store_events, :created_at
    add_index :event_store_events, :event_type
    add_index :event_store_events, :event_id, unique: true
\end{lstlisting}

Matome, jog kiekvienas įvykis turi srauto pavadinimą, įvykio tipą, unikalų identifikatorių, tam tikrus meta duomenis (čia gali būti tokia informacija kaip kliento IP, šalis iš kurios buvo atlikta užklausa ir t.t.), duomenų laukas, kuris aktyvaus įrašo pagalba serializuojamas į maišos duomenų struktūrą (angl. hash) bei sukūrimo laiką. Taipogi sukuriami reikalingi indeksai, kurie reikalingi greitesnėms užklausoms filtruojant pagal indeksuojamus lentelės stulpelius.

Norint naudoti bibliotekos funkcionalumą, tereikia sukurti \lstinline|RailsEventStore::Client| klasės egzempliorių:

\begin{lstlisting}[]
    client = RailsEventStore::Client.new
\end{lstlisting}

\subsubsection{Įvykių kūrimas}

Kurti įvykius naudojantis šia biblioteka yra tikrai paprasta. Tereikia apibrėžti įvykio modelį išplečiant \lstinline{RailsEventStore::Event} klasę:

\begin{lstlisting}[]
   class ProductAdded < RailsEventStore::Event 
  end
\end{lstlisting}

Dabar galima sukurti įvykio egzempliorių ir išsaugoti į duomenų bazę:

\begin{lstlisting}[]
   stream_name = "product_1" 
  event_data = {data: { name: "Product" }}
  event = ProductAdded.new(event_data)
  # publishing event for specific stream
  client.publish_event(event, stream_name)
  # publishing global event with stream_name == 'all'
  client.publish_event(event)
\end{lstlisting}

Biblioteka suteikia galimybę kurti ne tik specifinius įvykius bet ir globalius. \lstinline|event_id| yra neprivaloma reikšmė. Jeigu ji neperduodama, biblioteka pati sugeneruoja unikalų identifikatorių.

``RailsEventStore'' biblioteka taip pat turi optimistinę lygiagretumo kontrolę. Galima iš anksto apibrėžti laukiamą srauto versiją bekuriant įvykį. Šiuo atveju tai paskutinio įvykio reikšmė:

\begin{lstlisting}[]
 stream_name = "product_1" 
  event_data = { 
      data: { name: "Product" }, 
      event_id: "b2e526fd-609d-4ds7-b2df-c624575c8edd" 
  }
 event = ProductAdded.new(event_data) 
  expected_version = "951d352a-a53v-42a1-a5zz-as24chuf5b2l"
 client.publish_event(event, stream_name, expected_version)
\end{lstlisting}

\subsubsection{Įvykių skaitymas}

Biblioteka pateikia kelis būdus skaityti įvykius iš duomenų bazės. Visais atvejais įvykiai yra išrūšiuoti didėjančiai.

Galime skaityti tam tikrą skaičių įvykių pradedant tam tikru įvykiu:

\begin{lstlisting}[]
stream_name = "product_1" 
start_event = "b2d506fd-409d-4ec7-b02f-c6d2295c7edd"
count = 40
client.read_all_events(stream_name, start_event, count)
\end{lstlisting}

Galime skaityti visus įvykius:

\begin{lstlisting}[]
stream_name = "product_1" 
client.read_all_events(stream_name)
\end{lstlisting}

Galime skaityti apskritai visus įvykius

\begin{lstlisting}[]
client.read_all_streams
\end{lstlisting}

\subsubsection{Įvykių trinimas}

Įvykių kaupimo principas teigia, jog įvykių žurnalas yra visa sistemos istorija ir įvykiai netrinami. Tačiau gali atsirasti tokia situacija, jog programuotojas dirba lokaliai ir tiesiog testuojasi sistemą ir bando funkcionalumą, nenori užteršti istorijos. Dėl šios priežasties biblioteka palieka galimybę trinti įvykius. Tačiau reiktų gerai pagalvoti prieš naudojant šią komandą.

\begin{lstlisting}
stream_name = "product_1"
client.delete_stream(stream_name)
\end{lstlisting}

\subsubsection{Prenumeratų mechanizmas}

Biblioteka leidžia sinchroniškai klausyti specifinių įvykių. Vienintelis reikalavimas yra, jog prenumeratoriaus klasė turi įgyvendinti \lstinline|handle_event(event)| metodą.

Šis funkcionalumas yra įgyvendintas naudojant reaktoriaus projektavimo šabloną (angl. Reactor pattern). Kuris bus aprašytas vėliau. Pavyzdys pateiktas žemiau:

\begin{lstlisting}
class CartReadModel
    def handle_event(event)
        if event.event_type == 'AddToCart'
            add_to_cart(event.data)
        end
        if event.event_type == 'RemoveFromCart'
            remove_from_cart(event.data)
        end
    end
    private
    def add_to_cart(event_data)
        #Implementation here
    end
    def remove_from_cart(event_data)
        #Implementation here
    end 
end
 
cart = CartReadModel.new
client.subscribe(cart, ['AddToCart', 'RemoveFromCart']) 
\end{lstlisting}

Galima pastebėti įvykių srautas gali būti begalinis, apibrėžiama, kas nutikus įvykiui yra įvykdoma, tai yra atnaujima dabartinė prekių krepšelio reikšmė. Prenumeruojami iškart keli įvykių tipai, tai yra 2 skirtingi srautai. Galime šį veikimą laikyti kaip reaktyvaus operatoriaus \lstinline|merge| realizaciją.

\subsection{Reaktyvus programavimas bei įvykių kaupimas kartu}

\subsubsection{Idėja}

TODO:

Privalumai:

* Lengviau mąstyti apie kuriamą sistemą, kai loginiai vienetai yra labiau atskirti.

\subsubsection{Reaktoriaus projektavimo šablonas}

\textbf{Skyrius bus pateiktas ketvirtojo semestro metu}

\subsubsection{Realizacija}

\textbf{Skyrius bus pateiktas ketvirtojo semestro metu}

Skyrius aprašys iššūkius ir realizacijos detales apjungiant nagrinėtų reaktyvių programavimo bibliotekų idėjas kartu su ``RalsEventStore'' biblioteka.

Nagrinėtose Ruby reaktyvaus programavimo bibliotekose buvo panaudotas stebėtojo ir iteratoriaus projektavimo šablonai, o RailsEventStore bibliotekoje naudojamas reaktoriaus projektavimo šablonas. Todėl bus gilinamąsi į būdą juos sujungti.

\subsubsection{Apribojimai}

\textbf{Skyrius bus pateiktas ketvirtojo semestro metu}

Čia bus pateikti ``RailsEventStore'' bibliotekos apribojimai. Pavyzdžiui įvykiai yra apdorojami sinchroniškai, tai turi ir privalumų ir minusų (našumas).

\subsection{Tolimesni darbai}

\textbf{Skyrius bus pateiktas ketvirtojo semestro metu}

Bus pateiktos temos ir idėjos, kurias galima analizuoti ir kurios praverstų tobulinant šį darbą bei pačią RailsEventStore biblioteką.

\subsection{Darbai numatomi 4-ame semestre}

\begin{itemize}
  \item Pabaigti visus nepabaigtus skyrius (santraukos, išvados, realizacija).

  \item Papildyti darbą įžvalgomis realizuojant aprašytus pakeitimus RailsEventStore.

  \item Pabandyti gauti įžvalgų iš RailsEventStore kūrėjų apie mano inovatyvų sprendimą RailsEventStore programavimo bibliotekoje. Įsivaizduoju tai kaip atviro kodo papildinį, kurį viešai gali peržiūrėti, ar privatus susirašinėjimas.

  \item Paanalizuoti kaip galima įvykius atkartoti naudojant reaktyvius operatorius, kadangi analizuojant teoriją buvo minėta, jog tai gali būti keblumas.

  \item Norėtųsi darbo teorinę dalį įžvalgomis apie reaktyvaus programavimo teikiamus pranašumus, tokius kaip kodo suprantamumas, programuotojo produktyvumas remiantis Guido Salvaneschi darbu \cite{Salvaneschi:2014:ESP:2635868.2635895}.

  \item Norėtųsi darbo teorinę dalį papildyti apie reaktyvaus programavimo trūkumus remiantis \cite{Bainomugisha:2013:SRP:2501654.2501666} darbu.

  \item Darbo formatavimas ir teksto klaidų patikrinimas (pavyzdžiui kabučių naudojimas) priklauso darbui 4-ame semestre pagal MIF reikalavimus.

  \item Papildyti santrumpas ir paaiškinimus.
\end{itemize}
