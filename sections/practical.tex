Šioje dalyje bus bandoma parodyti, jog reaktyvų programavimą galima panaudoti įvykių kaupimo sistemose. Pirmiausia nagrinėjami jau esantys reaktyvaus programavimo bei įvykių kaupimo programavimo karkasai/bibliotekos. Kad būtų galima susidaryti bendrą vaizdą ir suvokti įvykių kaupimo sistemas, pirmiausia projektuojamas pavyzdinis įvykių kaupimo sistemos architektūros modelis. Toliau aprašomos šio pavyzdinio architektūros modelio komponentų žemesnio lygmens realizacijos detalės, kūrimo gairės. Atsižvelgiant į DDD, prieš pateikiant konkrečius pavyzdžius, skaitytojas yra supažindinamas su domeno sritimi bei galimais įvykiais. Sekančiame poskyryje aprašomas alternatyvus būdas kurti skaitymo modelį pritaikant reaktyvaus programavimo principus ir paslepiant operacijų su duomenų saugykla realizacijos detales.

\subsection{Programavimo kalba}

Pasirinkta griežtai tipizuota, dinaminė ``Ruby'' kalba, palaikanti tiek objektinį, tiek funkcinį programavimą. Kalba yra viena populiariausių atviro kodo talpykloje ``Github'', plačiai naudojama informacinių technologijų industrijoje (``Github'', ``AirBnb'', ``Etsy'', ``Shopify''), lengvai skaitoma, turi daugybę kokybiškų bibliotekų bei atitinka darbo tiksle išsikeltą sąlygą.

% Reaktyvių įvykių sistemų kūrimo gairėms aprašyti yra pasirinkta atviro kodo serverio pusės saityno programų programavimo karkasas ``Ruby on Rails''\footnote{http://rubyonrails.org/}, parašytas ``Ruby'' kalba. ``Ruby on Rails'' yra paremtas modelio-vaizdo-kontrolieriaus (MVC) projektavimo šablonu, kurį dar 9 dešimtmetyje aprašė Glenn Krasner ir Stephen Pope kaip bendrinę sąvoką \cite{Krasner:1988:CUM:50757.50759}. Verta pabrėžti, jog šis projektavimo šablonas jau buvo naudojamas ir anksčiau Smalltalk programavimo kalboje. Darbo autorius, siekiant išmokti ar sužinoti daugiau apie šį programavimo karkasą, ypatingai rekomenduoja Michael Hartl knygą ``Ruby on Rails Tutorial (Rails 5) Learn Web Development with Rails''\footnote{https://www.railstutorial.org/book}, kuri yra nemokama.

% Darbo autorius turi keletą metų profesionalaus darbo su šiomis technologijomis patirties, todėl praktinėje dalyje bus analizuojamos bibliotekos ar programavimo karkasai ir pateikti kodo pavyzdžiai, parašyti ``Ruby'' kalba.

\subsection{Reaktyvus programavimas Ruby kalboje}

Žemesniame lygyje paradigma iš esmės yra dviejų kūrimo šablonų konstrukcija, naudojama jau daugiau nei 20 metų. Faktiškai viena iš populiariausių kūrimo šablonų knygų yra „Gang of Four“, kurioje aprašyti šie du kūrimo šablonai: iteratoriaus ir stebėtojo šablonai \cite{GOF:DesignPattern}. Tai yra du elgsenos kūrimo šablonai, charakterizuojantys objektų ir klasių sąveiką ir atsakomybę.

\subsubsection{Iteratorius}

Pagrindinė šio šablono (iteratoriaus) idėja – atsakomybė už sąrašo objekto prieigą ir perėjimą. Iteratoriaus klasė apibrėžia prieigos prie sąrašo elementų sąsają. Iteratoriaus objektas atsakingas už esamo elemento stebėjimą; t. y. jis žino, kurie elementai jau buvo pereiti.

„Ruby“ programavimo kalboje \lstinline|Enumerable| modulis kaip tik tai ir daro: pateikia surašytuvą, kuriame yra uždari duomenys ir perėjimo metodai. Parašykime trumpiau: „Ruby“ iteratorius – tai klasės, į kurią įtrauktas \lstinline|Enumerable| modulis, egzempliorius, kuris yra beveik bet koks rinkinys.

\subsubsection{Stebėtojas}

Stebėtojo šablonas yra kūrimo šablonas, kuriame objektas (vadinamas tema) tvarko jo priklausinių (vadinamų stebėtojais) sąrašą ir automatiškai praneša apie bet kokius būsenos pasikeitimus, paprastai iškviesdamas vieną iš jų metodų. Paprastai jis naudojamas paskirstytųjų įvykių tvarkymo sistemoms realizuoti.

Iš esmės temos yra objektai, kurie siunčia pranešimus į objektus, stebinčius tokias temas. Temos priverstinai įkelia pranešimus stebėtojams, todėl tai ir vadinama stebėtojo šablonu.

„Ruby“ programavimo kalba turi \lstinline|Observable| modulį standartinėje bibliotekoje, kurioje pateikiamas paprastas mechanizmas, skirtas vienam objektui (temai) informuoti prenumeratorių rinkinį (stebėtojus) apie bet kokį būsenos pasikeitimą.

\subsubsection{Reaktyvaus programavimo bibliotekos}

Darbo autoriui pavyko rasti 2 reaktyvaus programavimo bibliotekas ``Ruby'' kalboje, todėl jos bus plačiau aptartos.

\begin{itemize}
  \item ``RxRuby''\footnote{https://github.com/ReactiveX/RxRuby} - 595 žvaigždutės bei 52 išsišakojimai, paskutinis atnaujinimas įvyko 2017 metų sausį. (Žiūrėta 2017-01-08)

  \item ``Frappuccino''\footnote{https://github.com/steveklabnik/frappuccino} - 370 žvaigždučių bei 32 išsišakojimai, paskutinis atnaujinimas įvyko 2016 metų vasarį. (Žiūrėta 2017-01-08)
\end{itemize}

``RxRuby'' biblioteka turi labiau apribojančią ``Apache'' licenziją (2 versija) lyginant su ``Frappuccino'' MIT licenzija.

\subsubsection{RxRuby}

Pirmiausia pažiūrėkime kaip veikia ``RxRuby'' paprasčiausioje formoje:

\begin{lstlisting}[]
  RxRuby::Observable.just(7)
\end{lstlisting}

\lstinline|RxRuby::Observable| yra srautas. Srautas yra tema (arba objektas), kurį galima prenumeruoti (arba stebėti). \lstinline|RxRuby::Observable| modulis pats nedaro nieko, nebent kuris nors jo metodas bus iškviestas. Tęskime pavyzdį:

\begin{lstlisting}[]
  stream = RxRuby::Observable.just(7)
  stream.subscribe { |num| puts "Gautas skaicius #{num}" }
\end{lstlisting}

Objektas, kurį gauname, yra tiesiog skaičius 7, apgaubtas kaip tema. Kadangi tema realizuoja daugumą \lstinline|Enumerable| modulio metodų, galima su juo daryti praktiškai bet ką. Tačiau, kad išvengtume sudėtingumo šiame pavyzdyje, tiesiog prenumeruokime temą ir perduokime \lstinline|lambda| konstrukciją. \lstinline|Lambda| bus iškviesta kiekvieną kartą, kai srautas gaus informaciją (šiuo atveju tik kartą).

Šio pavyzdinio atvejo išvestis bus:

\begin{lstlisting}[]
  Gautas skaicius 7
\end{lstlisting}

Kadangi turime daug \lstinline|Enumerable| modulio metodų, kuriuos galime naudoti, galime kažką nuveikti su masyvu. Yra 2 būdai dirbti su masyvais ``RxRuby'' bibliotekoje: naudojant rėžį ir paprastus masyvus.

\begin{lstlisting}[]
  RxRuby::Observable.range(1,10)
    .select { |num| num.even? }
    .sum
    .subscribe { |s| puts "Suma lyginiu skaiciu tarp 1 ir 10 yra: #{s}" }
\end{lstlisting}

Grąžins:

\begin{lstlisting}[]
  Suma lyginiu skaiciu tarp 1 ir 10 yra: 30
\end{lstlisting}

Paanalizuokime šį pavyzdį. Pirmiausia sukuriamas temos rėžis, su skaičiais tarp 1 ir 10. Tada iškviečiamas filtravimo operatorius \lstinline|select| temai, perduodant \lstinline|lambda| kaip parametrą. \lstinline|lambda| priima kiekvieną rėžio skaičių kaip parametrą ir filtruoja visus lyginius temos skaičius, grąžindama naują temą. Iškvietus \lstinline|sum| operatorių, susumuojami visi lyginiai skaičiai.

Galiausiai operatoriaus \lstinline|sum| grąžinama tema yra prenumeruojama. Prenumeruojant tema (arba duomenų srautas) tiesiog stebima ir \lstinline|lambda| iškviečiama. Kiekvieną kartą, kai tema gauna naują informaciją, duomenys perduodami lyg per ``piltuvėlį'' ir paskutinė \lstinline|lambda| atspausdina rezultatą.

\subsubsection{Frappuccino}

Steve Klabnik, žymus žmogus Ruby bendruomenėje dėl savo įnašo į atviro kodo projektus\footnote{https://github.com/steveklabnik}, 2013 metais pristatė reaktyvaus programavimo idėjas Ruby kalboje įvairiose konferencijose, tarp jų Euruko2013 \cite{klabnik:euruko}, RubyConf India 2013 \cite{klabnik:india} ir kitos.

Panagrinėkime šios bibliotekos pavyzdį:

\begin{lstlisting}[]
class Button
  def push
    emit(:pushed) # emit sends a value into the stream
  end
end

button = Button.new
stream = Frappuccino::Stream.new(button)

counter = stream
            .map { |event| event == :pushed ? 1 : 0 } # convert events to ints
            .inject(0) { |sum, n| sum + n } # add them up

counter.now # => 0

button.push
button.push
button.push

counter.now # => 3

button.push

counter.now # => 4
\end{lstlisting}

Ši biblioteka, kaip ir RxRuby, naudoja stebėtojo projektavimo šabloną. Sukuriant srautą, klasė \lstinline|Button| iš tikrųjų dinamiškai išplečia \lstinline|Frappuccino::Source| klasę, kuri turi \lstinline|emit| metodą. Taipogi \lstinline|Button| klasė paverčiama tema. \lstinline|emit| metodas iškviečia \lstinline|notify_observers(value)| metodą ir nauja reikšmė perduodama visiems stebėtojams.

Reaktyūs operatoriai (tokie kaip \lstinline|map|, \lstinline|merge| ir kiti) yra realizuoti grąžinant naują \lstinline|Frappuccino::Stream| objektą, kuris taip pat yra stebėtojas.

Šiame pavyzdyje yra sukuriamas mygtukas. Kiekvieną kartą, kai jis paspaudžiamas, visiems temos stebėtojams yra perduodamas pranešimas apie naują reikšmę. \lstinline|counter| kintamasis parodo, kiek kartų buvo paspaustas mygtukas. Nereikia kaskart iš naujo pritaikyti skaičiavimų, biblioteka leidžia apsirašyti elgseną vieną kartą deklaratyviai. \lstinline|map| reaktyvus operatorius transformuoja įvykio reikšmę - jeigu gautas simbolis \lstinline|:pushed| - reikšmė tampa 1, o priešingu atveju 0. Kitas operatorius \lstinline|inject| priima parametrą - pradinę reikšmę (šiuo atveju 0). Kiekvieną kartą, kai yra gaunama reikšmė, perduodamas kodo blokas (\lstinline|lambda|) yra iškviečiamas ir rezultatas atnaujinamas.

Rezultatas yra saugomas atmintyje, todėl programai baigus darbą, reikšmės yra prarandamos. Pranešimo metu tarptautinėje konferencijoje ``Euruko'' Steve Klabnik pasakojo, kad tokią biblioteką būtų galima naudoti vartotojo sąsajos programose. Jis teigia, jog pati idėja yra pasiskolinta iš funkcinių programavimo kalbų, ir įdomu pritaikyti naujus principus Ruby programavimo kalboje.

Kadangi reaktyvūs operatoriai grąžina naują stebėtoją - galima programuoti labai deklaratyviai:

\begin{lstlisting}
  merged_stream = Frappuccino::Stream.merge(one_stream , other_stream)
  filtered_stream = merged_stream.select{ |event| event == :pushed }

  filtered_stream.on_value do |event|
  # event will only ever be :pushed
  end
\end{lstlisting}

Biblioteka leidžia tiek apjungti, tiek filtruoti, tiek perduoti bloką kodo, kuris bus įvykdomas, kai tik srautas gaus naują informaciją.

\subsection{Įvykių kaupimas Ruby kalboje}

Įvykių kaupimo principą taikančių bibliotekų Ruby kalboje nėra daug. Galima būtų išskirti 3 žinomiausias:

\begin{itemize}
  \item ``RailsEventStore''\footnote{https://github.com/arkency/rails\_event\_store} - 212 žvaigždučių bei 18 išsišakojimų, paskutinis atnaujinimas įvyko 2016 metų gruodį. (Žiūrėta 2017-01-07)

  \item ``Sandthorn''\footnote{https://github.com/Sandthorn/sandthorn} - 110 žvaigždučių bei 4 išsišakojimai, paskutinis atnaujinimas įvyko 2016 metų balandį. (Žiūrėta 2017-01-07)

  \item ``Event Sourced Record''\footnote{https://github.com/fhwang/event\_sourced\_record} - 31 žvaigždutė bei 5 išsišakojimai, paskutinis atnaujinimas įvyko 2015 metų balandį. (Žiūrėta 2017-01-07)
\end{itemize}

Visos bibliotekos turi MIT licenziją. Verta paminėti, jog ``RailsEventStore'' anksčiau turėjo labiau apribojančią LGPLv3\footnote{https://github.com/arkency/rails\_event\_store/commit/212b202f227a98f131dc3e8711e431e1f126b475} licenziją (iki 2016 metų birželio).

Kadangi ``RailsEventStore'' yra aktyviai atnaujinima, populiariausia iš trijų, atviro kodo, įvykių kaupimą įgyvendinanti biblioteka, ją ir nagrinėsime.

\subsubsection{RailsEventStore}

Įvykių kaupimo biblioteka ``RailsEventStore'' naudoja atskirą biblioteką darbui su įvykiais pavadinimu ``rails\_event\_store\_active\_record''\footnote{https://github.com/arkency/rails\_event\_store\_active\_record}. Pagal nutylėjimą ji yra numatytoji, tačiau esant reikalui lengvai pakeičiama (pavyzdžiui, norint naudoti Greg Young ``GetEventStore''\footnote{https://geteventstore.com/} duomenų saugyklą). Taip pat yra galimybė naudoti duomenų saugyklą atmintyje.

\subsubsection{Naudojimas}

Kai į ``Ruby on Rails'' projekto \lstinline|Gemfile| failą jau įtrauktas \lstinline|rails_event_store| modulis, reikia sugeneruoti aktyvaus įrašo migraciją:

\begin{lstlisting}[]
  rails generate rails_event_store:migrate
  rake db:migrate
\end{lstlisting}

Ši migracija iš tikrųjų sukuria tokią lentelę:

\begin{lstlisting}
    create_table(:event_store_events) do |t|
      t.string      :stream,      null: false
      t.string      :event_type,  null: false
      t.string      :event_id,    null: false
      t.text        :metadata
      t.text        :data,        null: false
      t.datetime    :created_at,  null: false
    end
    add_index :event_store_events, :stream
    add_index :event_store_events, :created_at
    add_index :event_store_events, :event_type
    add_index :event_store_events, :event_id, unique: true
\end{lstlisting}

Matome, jog kiekvienas įvykis turi srauto pavadinimą, įvykio tipą, unikalų identifikatorių, tam tikrus meta duomenis (čia gali būti tokia informacija kaip kliento IP, šalis iš kurios buvo atlikta užklausa ir t.t.), duomenų laukas, kuris aktyvaus įrašo pagalba serializuojamas į maišos duomenų struktūrą (angl. hash) bei sukūrimo laiką. Taipogi sukuriami reikalingi indeksai, kurie reikalingi greitesnėms užklausoms filtruojant pagal indeksuojamus lentelės stulpelius.

Norint naudoti bibliotekos funkcionalumą, tereikia sukurti \lstinline|RailsEventStore::Client| klasės egzempliorių:

\begin{lstlisting}[]
    client = RailsEventStore::Client.new
\end{lstlisting}

\subsubsection{Įvykių kūrimas}

Kurti įvykius naudojantis šia biblioteka yra tikrai paprasta. Tereikia apibrėžti įvykio modelį išplečiant \lstinline{RailsEventStore::Event} klasę:

\begin{lstlisting}[]
   class ProductAdded < RailsEventStore::Event 
  end
\end{lstlisting}

Dabar galima sukurti įvykio egzempliorių ir išsaugoti į duomenų bazę:

\begin{lstlisting}[]
   stream_name = "product_1" 
  event_data = {data: { name: "Product" }}
  event = ProductAdded.new(event_data)
  # publishing event for specific stream
  client.publish_event(event, stream_name)
  # publishing global event with stream_name == 'all'
  client.publish_event(event)
\end{lstlisting}

Biblioteka suteikia galimybę kurti ne tik specifinius įvykius, bet ir globalius. \lstinline|event_id| yra neprivaloma reikšmė. Jeigu ji neperduodama, biblioteka pati sugeneruoja unikalų identifikatorių.

``RailsEventStore'' biblioteka taip pat turi optimistinę lygiagretumo kontrolę. Galima iš anksto apibrėžti laukiamą srauto versiją bekuriant įvykį. Šiuo atveju tai paskutinio įvykio reikšmė:

\begin{lstlisting}[]
 stream_name = "product_1" 
  event_data = { 
      data: { name: "Product" }, 
      event_id: "b2e526fd-609d-4ds7-b2df-c624575c8edd" 
  }
 event = ProductAdded.new(event_data) 
  expected_version = "951d352a-a53v-42a1-a5zz-as24chuf5b2l"
 client.publish_event(event, stream_name, expected_version)
\end{lstlisting}

\subsubsection{Įvykių skaitymas}

Biblioteka pateikia kelis būdus skaityti įvykius iš duomenų bazės. Visais atvejais įvykiai yra išrūšiuoti didėjančia tvarka.

Galime skaityti tam tikrą skaičių įvykių pradedant tam tikru įvykiu:

\begin{lstlisting}[]
stream_name = "product_1" 
start_event = "b2d506fd-409d-4ec7-b02f-c6d2295c7edd"
count = 40
client.read_all_events(stream_name, start_event, count)
\end{lstlisting}

Galime skaityti visus konkretaus srauto įvykius:

\begin{lstlisting}[]
stream_name = "product_1" 
client.read_all_events(stream_name)
\end{lstlisting}

Galime skaityti apskritai visus įvykius

\begin{lstlisting}[]
client.read_all_streams
\end{lstlisting}

\subsubsection{Įvykių trynimas}

Įvykių kaupimo principas teigia, jog įvykių žurnalas yra visa sistemos istorija ir įvykiai netrinami. Tačiau gali atsirasti tokia situacija, jog programuotojas dirba lokaliai ir tiesiog testuojasi sistemą ir bando funkcionalumą, nenori užteršti istorijos. Dėl šios priežasties biblioteka palieka galimybę trinti įvykius. Tačiau reiktų gerai pagalvoti prieš naudojant šią komandą.

\begin{lstlisting}
stream_name = "product_1"
client.delete_stream(stream_name)
\end{lstlisting}

\subsubsection{Prenumeratų mechanizmas}

Biblioteka leidžia sinchroniškai klausyti specifinių įvykių. Vienintelis reikalavimas yra, jog prenumeratoriaus klasė turi įgyvendinti \lstinline|call(event)| metodą.

Šis funkcionalumas yra įgyvendintas naudojant reaktoriaus projektavimo šabloną (angl. Reactor pattern). Pavyzdys pateiktas žemiau:

\begin{lstlisting}
class CartReadModel
    def call(event)
        if event.event_type == 'AddToCart'
            add_to_cart(event.data)
        end
        if event.event_type == 'RemoveFromCart'
            remove_from_cart(event.data)
        end
    end
    private
    def add_to_cart(event_data)
        #Implementation here
    end
    def remove_from_cart(event_data)
        #Implementation here
    end 
end
 
cart = CartReadModel.new
client.subscribe(cart, [AddToCart, RemoveFromCart]) 
\end{lstlisting}

Galima pastebėti - įvykių srautas gali būti begalinis, apibrėžiama, kas nutikus įvykiui yra įvykdoma, tai yra atnaujima dabartinė prekių krepšelio reikšmė. Prenumeruojami iškart keli įvykių tipai, tai yra 2 skirtingi srautai. Galime šį veikimą laikyti kaip reaktyvaus operatoriaus \lstinline|merge| realizaciją.

% \subsection{Reaktyvus programavimas bei įvykių kaupimas kartu}

% Pirmiausia reikėtų peržvelgti norimo pasiekti tikslo reikalavimus ir kiek iš jų ``RailsEventStore'' biblioteka atitinka:

% \begin{itemize}
%   \item reaktyviojo programavimo programos sąsaja (API) būtų valdoma atgalinių iškvietimų - sąlyga yra išpildoma, kadangi klientui galima perduoti lambda funkciją, kuri bus iškviečiama įvykus tam tikram įvykiui. Pavyzdys:

%   \begin{lstlisting}[]
%     in_memory_cart_processing = -> (event) { # do something }
%     client.subscribe(in_memory_cart_processing, [AddToCart, RemoveFromCart])
%   \end{lstlisting}

%   \item reaktyviojo programavimo programos sąsaja (API) būtų deklaratyvi, tai yra leistų naudoti reaktyvius operatorius - ši sąlyga nėra išpildoma, yra tik vienas metodas, kuris priima 2 parametrus ir įgalina prenumeruoti tam tikrus srautus bei įvykdyti atgalinius iškvietimus įvykus pasikeitimui.

%   \item įvykių kaupimo sistemos skaitymo modelis būtų kuriamas naudojant reaktyviojo programavimo programos sąsają (API) - ši biblioteka yra skirta būtent tam tikslui pasiekti.

%   \item įvykių kaupimo sistemos skaitymo modelį būtų galima kurti asinchroniškai arba reagavimas į apkrovą (Reaktyvumo manifestas). Iš tiesų biblioteka nesuteikia tokio funkcionalumo, tačiau jis yra pasiekiamas papildomų bibliotekų pagalba. Tai bus aprašyta vėliau.

%   \item atkuriamumas (Reaktyvumo manifestas) - šiai temai toliau bus skirtas skyrius.

%   \item našumas (Reaktyvumo manifestas) - šiai temai toliau bus skirtas skyrius
% \end{itemize}

% Dalį reikalavimų ši biblioteka tikrai įgyvendina, tačiau kitus reikės įrodyti arba parodyti sekančiuose skyriuose. Pirmiausia apžvelgime kaip atrodytų sistemos architektūra, pritaikanti tiek CQRS, tiek ES, tiek RP principus.

\subsection{Įprastas būdas kurti įvykių kaupimo sistemas IT industrijoje}

Kad būtų lengviau suprasti įvykių kaupimo sistemas bei jos komponentus, šiame poskyryje sukursime pavyzdinę įvykių kaupimo sistemos architektūros modelį, apjungiantį modelio-kontrolieriaus-vaizdo projektavimo šabloną, komandų-užklausų atskyrimo principą bei įvykių kaupimą. Šiame poskyryje bus demonstruojama kaip įprasta kurti tokias sistemas informacinių technologijų industrijoje bei bus gilinamąsi į kiekvieną komponentą žemesniame, kodo lygmenyje.

\subsubsection{Pavyzdinė įvykių kaupimo sistemos architektūra}

Tarkime turime tipinę saityno serverio sistemą, paremtą modelio-vaizdo-kontrolieriaus (MVC) projektavimo šablonu, kurį dar 9 dešimtmetyje aprašė Glenn Krasner ir Stephen Pope kaip bendrinę sąvoką \cite{Krasner:1988:CUM:50757.50759}.

\ref{img:mvc_cqrs} paveikslėlyje pavaizduotas architektūros modelis naudojant MVC projektavimo šabloną bei apjungiantis komandų-užklausų atskyrimo , įvykių kaupimo principus bei reaktyvųjį programavimą. Toliau ši diagrama bus išsamiau paaiškinta bei aprašyta pagrindiniai proceso tėkmės atvejai, komandų operacijos (keičiančios būseną) bei užklausų operacijos (nekeičiančios būsenos).

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{img/mvc_cqrs}
    \caption{MVC paremtas architektūros modelis, apjungiantis CQRS, ES bei reaktyvaus programavimo principus}
    \label{img:mvc_cqrs}
\end{figure}

\textbf{Pavyzdinis procesas - vartotojas įsideda daiktą į pirkinių krepšelį}

\begin{enumerate}
  \item Vartotojas pateikia užklausą programai įdėti pirkinį į pirkinių krepšelį. Pavyzdinė užklausos semantika - \lstinline|https://mysite.com/cart/add/1|.

  \item Saityno serveris gauna užklausą. Maršrutizatorius naudoja maršrutų failą \lstinline|config/routes.rb| ir identifikuoja kur reikia nusiųsti užklausą. Mūsų atveju \lstinline|cart| yra kontrolierius, \lstinline|add| yra norimas atlikti veiksmas, o \lstinline|1| yra parametras, nurodantis konkretų/unikalų pirkinį.

  \item Kontrolierius iškviečia komandą.

  \item Komanda gali patikrinti ar užklausa buvo teisinga. Jei užklausa buvo teisinga, kontrolierius įrašo sėkmingą arba nesėkmingą įvykį į įvykių kaupimo žurnalą. Taipogi komanda gali atlikti tam tikrus šalutinius efekus, tokius kaip elektronių žinučių siuntimas vartotojui.

  \item Kai įvykis įrašomas į įvykių kaupimo žurnalą, reaktyvaus programavimo programos sąsaja (API) reaguoja į įvykį pagal aprašytas taisykles. Taisyklės aprašo ką su tuo įvykiu reikia padaryti, bendru atveju tai dažniausiai yra dabartinės būsenos atnaujinimas tam tikroje kitoje duomenų saugykloje.

  \item Kai tik įvykis jau įrašytas į įvykių žurnalą, galima vartotojui pranešti apie sėkmingą rezultatą.
\end{enumerate}

\textbf{Pavyzdinis procesas - vartotojas peržiūri savo pirkinių krepšelį}

\begin{enumerate}
  \item Vartotojas pateikia užklausą programai peržiūrėti savo pirkinių krepšelį. Pavyzdinė užklausos semantika - \lstinline|https://mysite.com/cart|.

  \item Saityno serveris gauna užklausą. Maršrutizatorius naudojo maršrutų failą \lstinline|config/routes.rb| ir identifikuoka kuris kontrolierius atsakys į užklausą.

  \item Kontrolierius iškviečia skaitymo modelį, kuris naudojant Ruby on Rails karkasą įprastai būna supaprastintas (naudojant aktyvų įrašą nereikia rašyti SQL, jis yra sugeneruojamas). Pavyzdinė užklausa \lstinline|@cart = current_user.cart.all|.

  \item Dabartinis vartotojo pirkinių krepšelis yra nuskaitomas iš duomenų saugyklos. Čia reikia prisiminti galutinės darnos sąvybę. Esant didelei apkrovai, egzistuoja galimybė, jog bus nuskaitoma krepšelio būsena, kai pirkinys dar nepridėtas į krepšelį. Todėl toks sistemos projektavimas verčia labiau mąstyti apie pačią sistemą. Įprastiniu atveju, pirkinių krepšelis įvykdžius daikto pridėjimo scenarijų, aprašytą aukščiau, galėtų būti pridedamas vartotojo sąsajoje. Vartotojas matytų, jog pirkinys pridėtas į krepšelį, tačiau įvykių kaupimo programavimo programos sąsaja (API) dar galbūt nebūtų baigusi darbo. Kai vartotojas norėtų pirkti visus krepšelio pirkinius, reaktyviojo programavimo programos sąsaja (API) jau būtų baigusi darbą. Įprastiniu atveju tai trunka keliasdešimt milisekundžių.

  \item Galiausiai vartotojui pateikiamas krepšelio vaizdas.
\end{enumerate}

\subsubsection{Domeno modelis}

Remiantis literatūros analizėje aptartu domenu pagrįstu projektavimu - pradedant kurti įvykių kaupimo sistemą, pirmiausia reikia apsibrėžti domeno modelį, arba tiksliau agregatus, kuriuos aprašo Martin Fowler \cite{Fowler:Aggregate}. Naudojant įvykių kaupimą, domeno modelis yra sukuriamas remiantis domeno įvykiais. Duomenų struktūra nesaugo dabartinės būsenos, o saugo eilę domeno įvykių, kurie buvo pritaikyti agregatui nuo sistemos gyvavimo pradžios. Tai leidžia konstruoti agregatą, neatskleidžiant jo būsenos ir taip apsaugant jo invariantus.

Agregatas gali būti naujų domeno įvykių šaltinis - kiekvienas agregato metodo kvietimas gali publikuoti naują domeno įvykį. Kiekvienas agregato vidinės būsenos pasikeitimas privalo būti realizuotas publikuojant arba pritaikant domeno įvykį. Tik taip galima užtikrinti, jog taikant įvykius agregatas visada bus atkurtas į tą pačią būseną.

Pirmiausia apsibrėžkime domeno įvykius:

\begin{lstlisting}[]
module Events
  ProductAddedToCart = Class.new(RailsEventStore::Event)
  ProductRemovedFromCart = Class.new(RailsEventStore::Event)
  OrderCreated = Class.new(RailsEventStore::Event)
end
\end{lstlisting}

Pagal nagrinėjamą scenarijų minėti įvykiai apibrėžia šiuos veiksmus:

\begin{itemize}
  \item \lstinline|ProductAddedToCart| - pirkinys pridėtas į krepšelį.
  \item \lstinline|ProductRemovedFromCart| - pirkinys išimtas iš krepšelio.
  \item \lstinline|OrderCreated| - įvykdytas užsakymas.
\end{itemize}

Kai turime apsibrėžtus domeno įvykius, galime juos pritaikyti domeno objektui:

\begin{lstlisting}
module Domain
  class Order
    include AggregateRoot::Base

    AlreadyCreated    = Class.new(StandardError)
    MissingCustomer   = Class.new(StandardError)

    def initialize(id = SecureRandom.uuid)
      @id = id
      @state = :draft
    end

    def create(order_number, customer_id)
      raise AlreadyCreated unless state == :draft
      raise MissingCustomer unless customer_id
      apply Events::OrderCreated.create(@id, order_number, customer_id)
    end

    # ...

    def apply_order_created(event)
      @customer_id = event.customer_id
      @number = event.order_number
      @state = :created
    end

    private
    attr_accessor :id, :customer_id, :order_number, :state

    # ...
  end
end
\end{lstlisting}

Panagrinėkime šį atvejį išsamiau. \lstinline|Domain::Order| klasė turi metodą \lstinline|initialize|, kuris sukuria pradinę agregato būseną. Taip pat, klasė turi \lstinline|create| metodą. Pastarasis turėtų būti naudojamas kitų objektų, iškviečiant agregato funkcijas. Čia turėtų būti apsaugomi invariantai, tikrinama verslo logika, teisingumo taisyklės. Remiantis CQRS principu, šis metodas neturėtų grąžinti reikšmės - jis privalo būti tik įvykdomas arba nutraukti vykdymą iškeliant išimtinę situaciją. Taipogi šiame metode agregato būsena niekada nėra keičiama. Vietoje to yra sukonstruojamas ir pritaikomas naujas domeno įvykis (kurį apsirašėme anksčiau).

Reiktų detaliau panagrinėti iš kur įtraukiamas \lstinline|AggregateRoot::Base| modulis. Tai yra ``aggregate\_root''\footnote{https://github.com/arkency/aggregate\_root} biblioteka, kuri atkeliauja kartu su ``RailsEventStore biblioteka''. Ji įterpia metodą \lstinline|apply|:

\begin{lstlisting}
module AggregateRoot
  class DefaultApplyStrategy
    def call(aggregate, event)
      event_name_processed = event.class.name.demodulize.underscore
      aggregate.method("apply_#{event_name_processed}").call(event)
    end
  end
end

module AggregateRoot
  def apply(event)
    apply_strategy.(self, event)
    unpublished_events << event
  end

  private

  def unpublished_events
    @unpublished_events ||= []
  end

  def apply_strategy
    DefaultApplyStrategy.new
  end
end
\end{lstlisting}

Kviečiant \lstinline{apply Events::OrderCreated.create(@id, order_number, customer_id)} yra sukuriamas naujas domeno įvykis ir pritaikomas agregatui - būsena pasikeičia ir \lstinline|@unpublished_events| kintamasis saugo pakeitimus. Jis saugo visus agregato sukurtus domeno įvykius, kol metodas yra vykdomas.

Paskutinis svarbus momentas yra \lstinline|apply_order_created| metodas. Pastarasis atnaujina agregato būseną priklausomai nuo įvykusio domeno įvykio. Nesvarbu ar pats agregatas publikavo įvykį, ar įvykis buvo nuskaitytas iš įvykių žurnalo ir pritaikytas atkuriant dabartinę agregato būseną, šioje vietoje negali būti verslo logikos ar teisingumo taisyklių. Tai tik būsenos atkūrimas, o istorijos keisti negalima, kaip buvo nagrinėta literatūroje.

\subsubsection{Komandos}

Komanda yra paprastas objektas, kuris apibrėžia parametrus veiksmo vykdymui. Remiantis domenu paremtu projektavimu, komanda turėtų būti pavadinta bendrąja verslo kalba (skvarbiąja kalba) ir išreikšti vartotojo ketinimą. Prieš komandos vykdymą turėtų būti užtikrintos teisingumo taisyklės. Teisingumo taisyklės turėtų būti paprastos, pagrįstos pačiais duomenimis, bet ne verslo logika (Kaip jau minėjome praeitame skirsnyje, domeno objektas tikrina verslo logiką).

Pažvelkime į komandos pavyzdį:

\begin{lstlisting}
module Command
  class CreateOrder < Base
    attr_accessor :order_id
    attr_accessor :customer_id

    validates :order_id, presence: true
    validates :customer_id, presence: true

    alias :aggregate_id :order_id
  end
end
\end{lstlisting}

``Ruby'' programavimo kalboje tai dar žinoma kaip formos objektai (angl. Form Objects)\footnote{https://webuild.envato.com/blog/creating-form-objects-with-activemodel-and-virtus/}. Iš esmės, norint leisti patikrinti teisingumo taisykles, tėvinė klasė \lstinline|Base| naudoja dalį \lstinline|ActiveModel| funkcijų:

\begin{lstlisting}
module Command
  class Base
    include ActiveModel::Model
    include ActiveModel::Validations
    include ActiveModel::Conversion

    def initialize(attributes={})
      super
    end

    def validate!
      raise ValidationError, errors unless valid?
    end

    def persisted?
      false
    end
  end
end
\end{lstlisting}

\subsubsection{Komandų apdorojimas}

Komandų doroklė yra pradinis domeno taškas, turintis instrumentuoti domeno objektus ir domeno tarnybas bei vykdyti domeno objektų metodus. Komandų doroklę galima apsirašyti:

\begin{lstlisting}
module Command
  class Handler
    def initialize(repository:, **_)
      @repository = repository
    end

    protected
    def with_aggregate(aggregate_id)
      aggregate = build(aggregate_id)
      yield aggregate
      repository.store(aggregate)
    end

    private
    attr_accessor :repository

    def build(aggregate_id)
      aggregate_class.new(aggregate_id).tap do |aggregate|
        repository.load(aggregate)
      end
    end
  end
end
\end{lstlisting}

Metodas \lstinline|build| ištraukia įvykius iš įvykių saugyklos, naudodamasis agregato unikaliu identifikatoriumi ir paduodamas įvykių srauto vardą. Komandų doroklė iš pradžių atkuria agregato būseną ir tada išsaugo pakeitimus įvykių žurnale. Prisiminkime praeitame skirsnyje aprašytą \lstinline|unpublished_events| kintamąjį. Štai čia atsiskleidžia tikroji jo paskirtis, visi dar nepublikuoti įvykiai yra išsaugomi. Kai įvykis yra išsaugomas, visi prenumeratoriai, kurie stebi ši įvykį (arba temą) yra informuojami apie pasikeitimus.

Taigi išplečiant šį atvejį, galime pavaizduoti užsakymo komandų doroklę:

\begin{lstlisting}
module CommandHandlers
  class CreateOrder < Command::Handler
    def call(command)
      with_aggregate(command.aggregate_id) do |order|
        order.create(command.customer_id)
      end
    end

    private

    def aggregate_class
      Domain::Order
    end
  end
end
\end{lstlisting}

Čia \lstinline|with_aggregate(command.aggregate_id)| metodas grąžina domeno objektą \lstinline|Domain::Order|, atkurtą iš anksčiau sistemoje įvykusių įvykių, kurie skaitomi iš įvykių žurnalo. Tada komandų doroklė iškviečia \lstinline|create| metodą perduodama parametrus, kuriuos gavo iš komandos.

Supratus domeno įvykius, komandas bei komandų doroklę iškyla klausimas: o kaip kontrolierius iškviečia komandą?

Paprastesniam naudojimui galima sukurti atskirą modulį, kurį galima labai paprastai įtraukti į \lstinline|ApplicationController|, jame prirašius \lstinline|include Command::Execute|:

\begin{lstlisting}
module Command
  module Execute
    def execute(command, **args)
      command.validate!
      args = AggregateRoot::Repository.new(event_store) if args.empty?
      handler_for(command).new(**args).call(command)
    end

    private
    def handler_for(command)
      {
        Command::CreateOrder          => CommandHandlers::CreateOrder,
        Command::AddItemToBasket      => CommandHandlers::AddItemToBasket,
        Command::RemoveItemFromBasket => CommandHandlers::RemoveItemFromBasket,
      }.fetch(command.class)
    end
  end
end
\end{lstlisting}

Šiuo atveju iš pradžių yra tikrinamos komandos teisingumo taisyklės. Sukuriamas objektas prieigai prie įvykių žurnalo skaitymo. \lstinline|handler_for| metodas tiesiog aprašo taisykles kuriomis komandos yra priskiriamos jų doroklėms.

Galiausiai iš kontrolieriaus galime sukurti užsakymą:

\begin{lstlisting}
def create
  cmd = Command::CreateOrder.new(order_params)
  execute(cmd)

  redirect_to Order.find_by_uid(cmd.order_id), notice: 'Order was successfully created.'
end
\end{lstlisting}

\subsubsection{Skaitymo modelio kūrimas}

Iki šiol aprašėme kaip vartotojas vykdo komandas, kaip jos apdorojamos, kur įvykdoma domeno logika, kaip publikuojami ir saugomi domeno įvykiai. Prisiminkime, jog domeno objektai neleidžia paimti (arba nerodo) dabartinės būsenos, todėl reikia kito kelio konstruoti duomenis pateikimui vartotojui (vaizde), tai yra skaitymo pusei. Čia verta pažymėti, jog duomenys yra denormalizuoti, jie yra būtent tokie, kokių reikia tam vaizdui paruošti. Šis sprendimas turi didelį našumo privalumą, kai reikalingos labai greitos užklausos, nes nereikia vykdyti sudėtingų užklausų (pvz.: sujungimo). Duomenų saugykla šiuo atveju gali būti bet kokia duomenų bazė tiek reliacinė, tiek grafų ar NoSQL.

Kad galėtume naudotis šiomis greitomis užklausomis, pirmiausia reikia paruošti skaitymo pusės duomenis. Reikia apdoroti įrašytus įvykius ir juos transformuoti į norimą vaizdą.

Taigi galime apsirašyti įvykių kaupimo sistemos maršrutizatorių:

\begin{lstlisting}
module EventStoreSetup
  def event_store
    @event_store ||= RailsEventStore::Client.new.tap do |es|
      es.subscribe(Denormalizers::OrderCreated.new, [Events::OrderCreated])
      es.subscribe(Denormalizers::ProductAddedToCart.new, [Events::ProductAddedToCart])
      es.subscribe(Denormalizers::ProductRemovedFromCart.new, [Events::ProductRemovedFromCart])
    end
  end
end
\end{lstlisting}

Įvykių maršrutizatorius aprašo koks duomenų denormalizatorius apdoroja domeno įvykį arba aibę domeno įvykių. Iš tikrųjų tai ta pati pagrindinė paskirtis kaip ir maršrutizatoriaus MVC projektavimo šablone, kuris pasako kokią užklausą kuris kontrolierius apdoros.

Pažiūrėkime į užsakymo denormalizatoriaus kodą:

\begin{lstlisting}
module Denormalizers
  class OrderCreated
    def call(event)
      return if Order.where(uid: event.data.order_id).exists?
      order = ::Order.new.tap do |o|
        o.uid = event.data.order_id
        o.number = event.data.order_number
        o.customer = Customer.find(event.data.customer_id).name
        o.state = "Created"
      end
      order.save!
    end
  end
end
\end{lstlisting}

Pagrindinė jo paskirtis išsaugoti gautus duomenis į tam tikrus skaitymo duomenų saugyklos stulpelius (ar įrašus - priklausomai nuo duomenų saugyklos tipo). Tačiau atidžiau pažvelkime į šią eilutę - \lstinline|return if Order.where(uid: event.data.order_id).exists?|. Jeigu įvykis jau egzistuoja - jis nėra atnaujinamas. Tai jau tam tikra teisingumo taisyklė, kuri yra patikrinama prieš įrašant duomenis į duomenų saugyklą. Taigi denormalizatorius šiuo atveju turi dvi atsakomybes - filtruoti duomenis ir išsaugoti duomenis į pasirinktą duomenų saugyklą. Kaip pamatysime vėliau darbe, kuriant biblioteką, apjungiančią reaktyvaus programavimo ir įvykių kaupimo principus, skaitymo modelio kūrimas gali būti supaprastintas.

% Šią atsakomybę būtų galima padalinti panaudojant reaktyvaus programavimo išskirtinę sąvybę - reaktyvius operatorius. Juk įvykiai, kurie nebus apdoroti galėtų ir nepasiekti denormalizatoriaus. Daugiau bus parodyta sekančiame poskyryje, o dabar pažvelkime į sutrumpintą įvykių maršrutizatoriaus kodą šiuo atveju:

% \begin{lstlisting}
% module Filters
%   clas OrderExists
%     def self.execute(event)
%       Order.where(uid: event.data.order_id).exists?
%     end
%   end
% end

% module EventStoreSetup
%   def event_store
%     @event_store ||= RailsEventStore::Client.new.tap do |es|
%       es.subscribe([Events::OrderCreated])
%         .filter { |event| Filters::OrderExists.execute(event) }
%         .each { |event| Denormalizers::OrderCreated.call(event) }
%     end
%   end
% end
% \end{lstlisting}

% Šiuo atveju kodas tikrinantis ar užsakymas egzistuoja yra atskirtas ir iškeltas į atskirą filtrų modelį. \lstinline|es.subscribe([Events::OrderCreated])| iš tikrųjų yra srautas. Srautams aprašyti galima naudoti reaktyvius operatorius, juos jungti paduodant daugiau stebimų domeno įvykių kaip masyvą ar, šiuo atveju, iškviesti \lstinline|filter| metodą, paduodant jam \lstinline|lambda| bloką, kuris bus įvykdytas ateityje. Jeigu filtras grąžina \lstinline|false|, tai yra neigiamą reikšmę, jis neperduodamas toliau. Tolesnis blokas įvykdomas tik tada, kai filtras grąžina teigiamą reikšmę.

% Kaip buvo nagrinėta literatūros analizėje, įrodyta, jog deklaratyvus stilius yra pranašesnis už imperatyvųjį kodą. Sekančiame skyriuje panagrinėsime kokius privalumus toks atsakomybių atskyrimas suteikia.

% \subsubsection{Reaktyvūs operatoriai ``RailsEventStore'' bibliotekoje}

% Steve Klabnik idėjos, atėjusios iš funkcinio programavimo bendruomenės, sudomino ir Ruby bendruomenę. Deklaratyviai parašytas kodas dažnai yra lengviau skaitomas, suprantamas, galima labiau moduliarizuoti kodą, skaidyti į daug smulkesnius komponentus. Galėtų būti naudinga išplėsti ``RailsEventStore'' biblioteką reaktyviais operatoriais tokiais kaip filtravimo \lstinline|filter|, transformavimo \lstinline|map| bei pavyzdžiui imties mažinimo \lstinline|sample|.

% \textbf{Maršrutizatoriaus paskirtis}

% Dabartinis ``RailsEventStore'' įvykių ir jų apdorojų apibrėžimas atrodo labai paprastas. Jis panašus į MVC projektavimo šablono maršrutizatoriaus veikimą. Kai gaunama nauja informacija, pažiūrima į tos informacijos tipą bei priskiriamas reikiamas kontrolierius.

% Tačiau Ruby on Rails programavimo karkaso maršrutizatorius \lstinline|config/routes.rb| turi ir sudėtingesnių kalbos konstrukcijų, tokių kaip maršrutizatoriaus suvaržymai\footnote{http://guides.rubyonrails.org/routing.html}. Jie dažnai įveda saugumo ir švarumo į bendrą kuriamos sistemos kodą. Jie gali išvalyti bei validuoti informaciją, kuri bus perduodama kontrolieriui.

% Pačiu paprasčiausiu atveju validatorius gali atrodyti kaip:

% \begin{lstlisting}[]
% get   'user/:id'   => 'user#show', constraint: { id: /\d+/ }
% \end{lstlisting}

% Šis validatorius filtruoja tik tas užklausas, kur parametras \lstinline|id|| yra perduodamas kaip sveikasis skaičius. Jei jis toks nėra, užklausa net nepasiekia kontrolieriaus.

% Kitas maršrutizatoriaus apribojimų panaudojimo atvejis yra kontrolieriaus veiksmų supaprastinimas (ir jį palaikančio kodo). Tarkime turime kontrolierių:

% \begin{lstlisting}[]
%   def search_by
%     if params['sort']    == 'best_match'
%       #execute
%     elsif params['sort'] == 'trending'
%       #execute
%     elsif params['sort'] == 'new'
%       #execute
%     end
%   end
% \end{lstlisting}

% o tuo tarpu maršrutizatorius atrodo kaip:

% \begin{lstlisting}[]
%   get    'product/search' => 'search#search_by'
% \end{lstlisting}

% Panaudojant maršrutizatoriaus apribojimus galime išskaidyti atsakomybes ir padalinti veiksmus priklausomai nuo to kokie yra užklausos parametrai. Po pakeitimų \lstinline{config/routes.rb} gali atrodyti:

% \begin{lstlisting}[]
%   get    'product/search' => 'search#best_match',  constraints: BestMatchConstraint
%   get    'product/search' => 'search#trending',    constraints: TrendingSearchConstraint
%   get    'product/search' => 'search#new',         constraints: NewSearchConstraint

%   class BestMatchConstraint
%     def self.matches?(request)
%       request.query_parameters['sort'] == 'best_match'
%     end
%   end

%   class TrendingSearchConstraint
%     def self.matches?(request)
%       request.query_parameters['sort'] == 'trending'
%     end
%   end

%   class NewSearchConstraint
%     def self.matches?(request)
%       request.query_parameters['sort'] == 'new'
%     end
%   end
% \end{lstlisting}

% Po tokio išskaidymo kontrolieriaus metodai atrodytų daug švariau ir gražiau:

% \begin{lstlisting}
%   def best_match
%     # execute
%   end

%   def trending
%     # execute
%   end

%   def new
%     # execute
%   end
% \end{lstlisting}

% Toliau pateikiu kartais praktikoje pasitaikantį duomenų transformavimo pavyzdį maršrutizatoriuje, kai yra pridedami nauji duomenys:

% \begin{lstlisting}
% get 'photos/:id', to: 'photos#show', defaults: { format: 'jpg' }
% \end{lstlisting}

% Jeigu užklausos parametras \lstinline|format| buvo nenurodytas, numatytatasis parametras \lstinline|params[:format] = 'jpg'| bus perduotas kontrolieriui.

% Sukūrus reaktyvius operatorius ``RailsEventStore'' bibliotekoje būtų galima pasiekti panašių privalumų. Galima būtų turėti sudėtingesnį įvykių maršrutizatorių. Visų pirma būtų lengviau mąstyti apie kuriamą sistemą, kai loginiai vienetai yra labiau atskirti. Šiuo metu visa logika yra perkelta į skaitymo modelį, jei norime, kad įvykis nebūtų pritaikytas (dėl tam tikrų priežasčių), turime tą kodą aprašyti pačiame modelyje.

% \textbf{Filtravimo operatorius}

% Konstrukcija \lstinline|filter| veiktų kaip filtravimo operatorius ir leistų apdoroti tik tuos įvykius, kurie atitinka tam tikrą sąlygą. Pazydžiui būtų galima filtruoti vartotojus, kurie priklauso tam tikrai A/B testo grupei, ir tik tada pritaikyti tam tikrus veiksmus.

% \begin{lstlisting}
%   event_store.subscribe([ProductPurchase])
%              .filter { |event| User.find(event.user.id).ab_active? }
%              .each { |event| ApplyTestCaseScenario.execute(event) }
% \end{lstlisting}

% Tam tikras testinis atvejis yra pritaikomas tik tiems vartotojams, kurie priklauso A/B testo grupei.

% \textbf{Transformavimo operatorius}

% Konstrukcija \lstinline|map| leistų transformuoti įvykius bei galėtų būti naudinga eksperimentavimo tikslais. Turint visą sistemos verslo logikos įvykių istoriją galima būtų iš naujo pritaikyti visus įvykius ir stebėti sistemos elgseną kaitaliojant įvairius parametrus. Pavyzdžiui elektroninės komercijos sistemoje gali būti poreikis įsivesti tam tikrą pirkėjų lojalumo sistemą. Iš pradžių neaišku kiek kam kreditų skirti, kokį procentą nuo produkto sumos. Neaišku kurie vartotojai kiek kreditų sukaups ateityje. Tačiau turint istoriją galima šį atvejį paprastai sumodeliuoti lokaliai. Pažvelkime į pseudokodą:

% \begin{lstlisting}[]
% module Transformers
%   class StoreCreditsMapper
%     CREDITS_PERCENTAGE_FOR_PURCHASE = 0.3

%     def self.execute(event)
%       event.user.store_credits = event.product.price * CREDITS_PERCENTAGE_FOR_PURCHASE
%     end
%   end
% end

% event_store.subscribe([ProductPurchase])
%            .filter { |event| Filters::EligibleForBuyerLoyaltyProgram.execute(event) }
%            .map { |event| Transformers::StoreCreditsMapper.execute(event) }
%            .each { |event| ReadModels::User.call(event) }
% \end{lstlisting}

% Pritaikant visus įvykius iš naujo ir koreguojant tik \lstinline|CREDITS_PERCENTAGE_FOR_PURCHASE| yra gana lengva numatyti pirkėjų sukauptus kreditus per tam tikrą laiką. Toks įvykių maršrutizatoriaus kodas yra deklaratyvus, imperatyvios konstrukcijos yra pritaikomos tik tose vietose kur reikia. Toks būdas labai aiškiai padalintų atsakomybes į filtravimą, duomenų transformavimą ir skaitymo modelio būsenos atnaujinimo operacijas. To pasekoje nebereiktų visų šių veiksmų atlikti ir realizuoti skaitymo modelyje, kaip tai dažniausiai daroma. Skaitymo modelio kodas būtų trumpesnis ir rūpintųsi tik duomenų atnaujinimu. Be to tipiniu atveju nereiktų skaityti visų įrašytų įvykių nurodant likusių kreditų kiekį vartotojui. Užtektų iškviesti \lstinline|current_user.store_credits|.

% \textbf{Imties mažinimo operatorius}

% Imties mažinimo \lstinline|sample(n)| operatorius galėtų būti naudingas kuriant analitines aplikacijas, kur \lstinline|n| būtų išreikštas kaip procentas, kurio reikšmė būtų nuo 0 iki 100. Kai į įvykių žurnalą yra įrašoma labai daug įvykių, tik tam tikras procentas įvykių būtų toliau apdorojami. Bendru atveju šis operatorius galėtų būti išreikštas per \lstinline|filter| operatorių:

% \begin{lstlisting}[]
%   es.subscribe([RealtimeTimeEventAdded])
%      .filter { |event| rand(100) < 20 }
%      .each { |event| EventProcessor.call(event) }
% \end{lstlisting}

% Šiuo atveju \lstinline|rand(100)| sugeneruoja atsitiktinę reikšmę tarp 0 ir 99. Jei sugeneruota reikšmė bus mažesnė nei tarkime 20, tik tada \lstinline|EventProcessor| klasė bus iškviesta.

\subsubsection{Skaitymo pusės asinchroninis kūrimas}

Iš tiesų ``RailsEventStore'' biblioteka veikia sinchroniškai, tačiau skaitymo pusę generuoti galima ir asinchroniškai pasitelkiant papildomas bibliotekas tokias kaip ``Sidekiq''\footnote{https://github.com/mperham/sidekiq} ar ``Rescue''\footnote{https://github.com/resque/resque}. Šios bibliotekos pasižymi bendru bruožu - naudoja gijas apdoroti daugybę darbų tuo pačiu metu. Parametrai perduodami šiems darbams dažniausiai saugomi duomenų saugyklose atmintyje, tokiose kaip ``Redis''\footnote{https://redis.io/} ar ``Memcached''\footnote{https://memcached.org/} našumui užtikrinti.

Parodysime kodo pavyzdį kaip atrodytų asinchroninis užsakymo kūrimas panaudojant ``Sidekiq'':

\begin{lstlisting}
module Workers
  class OrderExists
    include Sidekiq::Worker

    def perform(order_id)
      Order.where(uid: order_id).exists?
    end
end

module Filters
  class OrderExists
    def self.execute(event)
      Workers::OrderExists.perform_async(event.data.order_id)
    end
  end
end
\end{lstlisting}

Čia matome, jog darbininko klasėje tereikia pridėti \lstinline|include Sidekiq::Worker| modulį ir įgyvendinti \lstinline|perform| metodą. Įvykdžius \lstinline|Workers::OrderExists.perform_async(event.data.order_id)|, parametrai (unikalus darbo identifikatorius, perduoti parametrai) yra išsaugomi atskiroje duomenų saugykloje (skirtoje būtent tam) į eilę. ``Sidekiq'' procesas tikrina atsiradusius naujus darbus šioje duomenų saugykloje, ir bendru atveju ima juos iš eilės ir priskiria laisvai gijai, kuri apdoroja rezultatą. Esant didesniai sistemos apkrovai yra ganėtinai nesunku pridėti dar vieną serverį, apdorojantį tokius asinchroninius darbus.

Toks asinchroninis darbų apdorojimas padidina sistemos našumą, padaro ją labiau išplečiama, tačiau kaip buvo minėta literatūroje, priverčia atidžiau mąstyti apie pačią sistemą dėl galutinės darnos principo.

Toks būdas gali būti naudingas darbams, kurie užtrunka ilgiau. Pavyzdžiui, sistemoje yra galimybė įkelti prekes ir jų paveikslėlius. Paveikslėlius reikia sumažinti, sukarpyti, suprastinti kokybę ar dar kitaip apdoroti. Toks procesas trunka ilgiau nei paprastas įrašymas į duomenų bazę, todėl iškėlimas būtų labai naudingas didinant sistemos našumą.

% \subsection{Reaktyvus programavimas bei įvykių kaupimas kartu}

% Praeitame poskyryje buvo pademonstruotas įvykių kaupimo sistemos skaitymo modelio kūrimas panaudojant egzistuojančią biblioteką. Tačiau toks bibliotekos panaudojimas nėra deklaratyvus, programuotojui tenka rašyti darbo su duomenų baze operacijas. Norima tokį pašalinį efektą paslėpti, jog būtų galima koncentruotis tik ties sprendžiama problema. Toliau bus aprašomas siūlomas esamos ``RailsEventStore'' praplėtimas leidžiantis kurti skaitymo modelį komponavimo būdu, paslepiantis duomenų bazės lygmens realizacijos detales.

% \subsubsection{Pavyzdinė domeno sritis ir įvykiai}

% Tarkime turime domeno sritį bankininkystė ir vartotojas gali atlikti šias operacijas, kurias atvaizduotų atitinkami įvykiai sistemoje:

% \begin{itemize}
%   \item \lstinline|AccountCreated| - susikurti sąskaitą, kuri turėtų unikalų sąskaitos identifikatorių ir einamąjį balansą.
%   \item \lstinline|MoneyDeposited| - įnešti pinigus į sąskaitą.
%   \item \lstinline|MoneyWithdrawn| - išsiimti pinigus.
% \end{itemize}

% \subsubsection{Skaitymo modelio kvietimas}

% Patogiam užklausų rašymui, pasirenkamas aktyvaus įrašo projektavimo šablonas, kuris buvo nagrinėtas literatūros analizėje.

% Norint surasti sąskaitą \lstinline|Account| pagal unikalų identifikatorių užtenka iškviesti:

% \begin{lstlisting}
%   Account.find_by(account_id: 'LT121000011101001000')
% \end{lstlisting}

% Norint atvaizduoti sąskaitas, kurios buvo atidarytos paskutinį mėnesį ir išrūšiuoti pagal naujumą užtenka iškviesti:

% \begin{lstlisting}
%   Account.filter(created_at: 1.month.ago..Time.current).order(created_at: :desc)
% \end{lstlisting}

% \subsubsection{Skaitymo modelio aprašas}

% Panaudodami \lstinline|event_store| kintamąjį, kuris yra duomenų srauto klientas, galime sukurti skaitymo modelį deklaratyviai:

% \begin{lstlisting}
%   event_store.
%     as(Account).
%     subscribe([AccountCreated, MoneyDeposited, MoneyWithdrawn]).
%     init( -> (state) { state.balance = 0} ).
%     when(AccountCreated), -> (state, event) { state.account_id = event.data[:account_id] }.
%     when(MoneyDeposited), -> (state, event) { state.balance += event.data[:amount] }).
%     when(MoneyWithdrawn), -> (state, event) { state.balance -= event.data[:amount] })
% \end{lstlisting}

% Verta pažymėti, jog čia nėra nė vienos operacijos su duomenų saugykla. Panagrinėkime šį kodo pavyzdį detaliau.

% \textbf{Kuriamo skaitymo modelio tipo operatorius}

% \lstinline|as(Account)| aprašo, jog bus kuriamas sąskaitos tipas. Įprastai programuotojas turi apsirašyti šį modelį pats \lstinline|class Account < ActiveRecord::Base; end|. Tačiau čia gali pasitarnauti meta programavimas \cite{Olsen:2007:DPR:1349728}, kuris leidžia programuotojams būti produktyvesniems generuojant dalį kodo. Šiuo atveju biblioteka leidžia paduoti ne tik jau aprašytą aktyvaus įrašo tipą, bet priima tiek eilutės, tiek simbolio tipą ir gali dinamiškai paveldėti aktyvaus įrašo bazinį tipą:

% \begin{lstlisting}
% read_model_type =
%   if defined_stream_type.is_a? String
%     Object.const_set(dynamic_name, Class.new(ActiveRecord::Base))
%   elsif defined_stream_type.is_a? Symbol
%     Object.const_set(defined_stream_type.to_s.capitalize, Class.new(ActiveRecord::Base))
%   else
%     defined_stream_type
%   end
% \end{lstlisting}

% Aprašomas duomenų srautas elgiasi kaip stebėtojas, bei prenumeruoja vieną ar daugiau temų panaudojant \lstinline|subscribe| metodą.

% \textbf{Pradinės reikšmės operatorius}

% \lstinline|init| metodas veikia kaip inicializatorius. Jeigu skaitymo modelis dar nėra saugomas duomenų saugykloje, sukuriant įrašą bus nustatoma pradinės įrašo reikšmės. Šiuo atveju sąskaitos balansas bus 0. Metodas priima \lstinline|lambda| funkciją, kuri bus iškviesta inicializavimo metu. Supaprastintai (bibliotekoje) tai galima pavaizduoti kaip:

% \begin{lstlisting}
% class ReadModel
%   def init(&blk)
%     Init.new(self, &blk)
%   end
% end

% class Init < ReadModel
%   def initialize(source, &blk)
%     @block = blk

%     source.add_observer(self)
%   end

%   def update(event)
%     return unless record_initialized?

%     record = @read_model_type.new
%     @blk.call(record)
%     record.save!
%   end
% end
% \end{lstlisting}

% Čia \lstinline|update| metodas yra iškviečiamas kiekvieną kartą, kai duomenų srautas gauna naują įvykį, o stebėtojas jį prenumeruoja. Ši supaprastinta realizacija iš esmės yra labai panaši į Steve Klabnik sukurtą reaktyvaus programavimo ``frappuccino'' bibliotekos vidinę realizaciją.

% \textbf{Tipo atitikimo operatorius}

% Operatorių \lstinline|when(Type, &blk)| galima vadinti tipo atitikimo operatoriumi. Perduodamas \lstinline|lambda| blokas bus iškviestas tik tada kai sistemoje įvykusio įvykio tipas bus toks, koks yra apibrėžtas.

% \textbf{\lstinline|each| operatorius}

% Kartais gali vertėti klausytis kelių srautų ir jiems pritaikyti bendras operacijas. Toks operatorius pseudokodas galėtų būti išreikštas kaip:

% \begin{lstlisting}
%   event_store.subscribe(Event).as(Type).each( -> (state, event) {  })
% \end{lstlisting}

% \textbf{Filtravimo operatorius}

% Tarkime vartotojas sistemoje gali tiek nusipirkti prekę, tiek užsisakyti, jog prekė būtų pagaminta pagal užsakymą. Gali kilti noras konstruoti skaitymo modelį, apjungiantį juos abu bei turint papildomų sąlygų. Pavyzdžiui vartotojui gali būti suteikiami kreditai už sėkmingą pirkimą tik tada, kai:

% \begin{itemize}
%   \item Pirkinio vertė yra didesnė nei 100 eurų.
%   \item Specialaus užsakymo vertė yra daugiau nei 50 eurų.
% \end{itemize}

% Tokį duomenų srautą būtų galima konstruoti panaudojant reaktyvų filtravimo operatorių \lstinline|filter| kaip:

% \begin{lstlisting}
%   product_orders_eligible_for_bonus =
%     event_store.subscribe([ProductPurchased]).
%                 filter( -> (event) event.data[:price_paid] > 100)

%   job_orders_eligible_for_bonus =
%     event_store.subscribe([JobOrderPurchased]).
%                .filter( -> (event) event.data[:price_paid] > 50)
% \end{lstlisting}

% \textbf{Srautų sujungimo operatorius}

% Apibrėžiant filtravimo operatorių, buvo sukurti 2 srautai, kurie yra filtruojami skirtingi. Norėdami pritaikyti bendrus veiksmus jiems, turime turėti galimybę juos sujungti. Šių filtruotų srautų sujungimo operatorius \lstinline|merge| atrodytų kaip:

% \begin{lstlisting}
%   merged_stream = product_orders_eligible_for_bonus.merge(job_orders_eligible_for_bonus)
% \end{lstlisting}

% Norint kurti skaitymo modelio aprašą iš kintamojo \lstinline|merged_stream| užtektų panaudoti jau minėtą kuriamo skaitymo modelio tipo apibrėžimo operatorių \lstinline|as(Type)|, inicializatoriaus operatorių \lstinline|init|, tipo atitikimo operatorių \lstinline|when| ar operatorių \lstinline|each| kiekvienam įvykio tipui.

% \textbf{Skirtingi būdai struktūrizuoti skaitymo modelio aprašą}

% Iš esmės \lstinline|lambda| blokas yra vykdomas, kai jam iškviečiamas \lstinline|call| metodas. Kadangi aprašyti operatoriai priima \lstinline|lambda| bloką kaip parametrą, esti papildomi būdai perduoti juos.

% Galima apsirašyti kintamąjį:

% \begin{lstlisting}
%   variable = -> (event) { }
% \end{lstlisting}

% Taip pat galima apsirašyti klasę, kuri turi \lstinline|call| metodą:

% \begin{lstlisting}
%   class Denormalizers::ReadModelType::Event
%     def call(state, event)
%       # implementation
%     end
%   end
% \end{lstlisting}

% Lankstumas suteikia galimybę laisvai struktūrizuoti kodą, sutrumpinti skaitymo modelio kūrimo aprašą, kas gali pagerinti projekto priežiūrą, skaitomumą bei programuotojo produktyvumą.

% \subsubsection{Apribojimai}

% Grįžkime prie vartotojo sąskaitos pavyzdžio. Jeigu norėtume kurti skaitymo modelį ir saugoti paskutinių 7 dienų sąskaitos balansą, susidurtume su sunkumais. Perduodamas \lstinline|lambda| blokas yra vykdomas tik tada, kai sistemoje atsitinka tam tikras įvykis. Tokiu atveju

% \textbf{Filtravimo operatorius}

% Konstrukcija \lstinline|filter| veiktų kaip filtravimo operatorius ir leistų apdoroti tik tuos įvykius, kurie atitinka tam tikrą sąlygą. Pazydžiui būtų galima filtruoti tik tas pinigų pervedimo operacijas, kurių pervedimo suma yra didesnė nei 100 eurų ir jas vėliau papildomai apmokestinti.

% \begin{lstlisting}
%   event_store.subscribe([MoneyWithdrawn]).
%              .as(A)
%              .filter -> (event) { event.data[:amount] > 100 }
%              .when(MoneyWithdrawn) -> (state, event) { state.fees += event[:amount] * 0.23 }
% \end{lstlisting}

% Šiam metodui perduodamas \lstinline|lambda| blokas turi grąžinti loginę reikšmę, tai yra \lstinline|true| arba \lstinline|false|.

% \textbf{Transformavimo operatorius}

% Konstrukcija \lstinline|map| leistų transformuoti įvykius bei galėtų būti naudinga eksperimentavimo tikslais. Turint visą sistemos verslo logikos įvykių istoriją galima būtų iš naujo pritaikyti visus įvykius ir stebėti sistemos elgseną kaitaliojant įvairius parametrus. Pavyzdžiui elektroninės komercijos sistemoje gali būti poreikis įsivesti tam tikrą pirkėjų lojalumo sistemą. Iš pradžių neaišku kiek kam kreditų skirti, kokį procentą nuo produkto sumos. Neaišku kurie vartotojai kiek kreditų sukaups ateityje. Tačiau turint istoriją galima šį atvejį paprastai sumodeliuoti lokaliai. Pažvelkime į pseudokodą:

% \begin{lstlisting}
% module Transformers
%   class StoreCreditsMapper
%     CREDITS_PERCENTAGE_FOR_PURCHASE = 0.3

%     def self.execute(event)
%       event.user.store_credits = event.product.price * CREDITS_PERCENTAGE_FOR_PURCHASE
%     end
%   end
% end

% event_store.subscribe([ProductPurchase])
%            .filter -> (event) { event.data[:eligible_for_buyer_loyalty_program] == true }
%            .map { |event| Transformers::StoreCreditsMapper.execute(event) }
% \end{lstlisting}

% Pritaikant visus įvykius iš naujo ir koreguojant tik \lstinline|CREDITS_PERCENTAGE_FOR_PURCHASE| yra gana lengva numatyti pirkėjų sukauptus kreditus per tam tikrą laiką. Toks įvykių maršrutizatoriaus kodas yra deklaratyvus, imperatyvios konstrukcijos yra pritaikomos tik tose vietose kur reikia. Toks būdas labai aiškiai padalintų atsakomybes į filtravimą, duomenų transformavimą ir skaitymo modelio būsenos atnaujinimo operacijas. To pasekoje nebereiktų visų šių veiksmų atlikti ir realizuoti skaitymo modelyje, kaip tai dažniausiai daroma. Skaitymo modelio kodas būtų trumpesnis ir rūpintųsi tik duomenų atnaujinimu. Be to tipiniu atveju nereiktų skaityti visų įrašytų įvykių nurodant likusių kreditų kiekį vartotojui. Užtektų iškviesti \lstinline|current_user.store_credits|.

% \subsection{Darbai numatomi 4-ame semestre}

% \begin{itemize}
%   \item Papildyti darbą įžvalgomis realizuojant aprašytus pakeitimus ``RailsEventStore''.

%   \item Aprašyti kaip pasikeitus skaitymo modelio kūrimo aprašui ar įvykus nenumatytai klaidai yra atkuriami įvykiai bei atnaujinama skaitymo modelio būsena.

%   \item Įvertinti skirtingus būdus kurti skaitymo modelį įvykių kaupimo sistemose.

%   \item Papildyti darbo teorinę dalį įžvalgomis apie reaktyvaus programavimo teikiamus pranašumus, tokius kaip kodo suprantamumas, programuotojo produktyvumas remiantis Guido Salvaneschi darbu \cite{Salvaneschi:2014:ESP:2635868.2635895}.

%   \item Papildyti darbo teorinę dalį apie reaktyvaus programavimo trūkumus remiantis \cite{Bainomugisha:2013:SRP:2501654.2501666} darbu.

%   \item Pateikti temas, kurios būtų naudingos tobulinant šį darbą.

%   \item Pateikti pavyzdinę programą, kuri panaudoja aprašytą skaitymo modelio kūrimo aprašą, panaudojant reaktyvius operatorius bei paslepiant operacijų su duomenų saugykla realizacijos detales.
% \end{itemize}

\input{sections/cappuccino}

